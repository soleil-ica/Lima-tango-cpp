static const char *RcsId = "$Id:  $";
//+=============================================================================
//
// file :         Pco.cpp
//
// description :  C++ source for the Pco and its commands. 
//                The class is derived from Device. It represents the
//                CORBA servant object which will be accessed from the
//                network. All commands which can be executed on the
//                Pco are implemented in this file.
//
// project :      TANGO Device Server
//
// $Author:  $
//
// $Revision:  $
//
// $Revision:  $
// $Date:  $
//
// SVN only:
// $HeadURL: $
//
// CVS only:
// $Source:  $
// $Log:  $
//
// copyleft :    Synchrotron SOLEIL 
//               L'Orme des merisiers - Saint Aubin
//               BP48 - 91192 Gif sur Yvette
//               FRANCE
//
//-=============================================================================
//
//  		This file is generated by POGO
//	(Program Obviously used to Generate tango Object)
//
//         (c) - Software Engineering Group - ESRF
//=============================================================================



//===================================================================
//
//	The following table gives the correspondence
//	between commands and method name.
//
//  Command name|  Method name
//	----------------------------------------
//  State       |  dev_state()
//  Status      |  dev_status()
//  Talk        |  talk()
//  GetCamInfo  |  get_cam_info()
//
//===================================================================
#include <tango.h>
#include <PogoHelper.h>

#include "Pco.h"
#include <PcoClass.h>


namespace Pco_ns
{

//+----------------------------------------------------------------------------
//
// method : 		Pco::Pco(string &s)
// 
// description : 	constructor for simulated Pco
//
// in : - cl : Pointer to the DeviceClass object
//      - s : Device name 
//
//-----------------------------------------------------------------------------
Pco::Pco(Tango::DeviceClass *cl, string &s)
    :Tango::Device_4Impl(cl, s.c_str()), m_dim(this)
{
    init_device();
}
Pco::Pco(Tango::DeviceClass *cl, const char *s)
    : Tango::Device_4Impl(cl, s), m_dim(this)
{
    init_device();
}
Pco::Pco(Tango::DeviceClass *cl, const char *s, const char *d)
    : Tango::Device_4Impl(cl, s, d), m_dim(this)
{
    init_device();
}
//+----------------------------------------------------------------------------
//
// method : 		Pco::delete_device()
// 
// description : 	will be called at device destruction or at init command.
//
//-----------------------------------------------------------------------------
void Pco::delete_device()
{
    INFO_STREAM << "Pco::Pco() delete device " << device_name << endl;
    //	Delete device allocated objects

    DELETE_DEVSTRING_ATTRIBUTE(attr_pixelRate_read);
    DELETE_SCALAR_ATTRIBUTE(attr_doubleImage_read);
    DELETE_SCALAR_ATTRIBUTE(attr_currentRecordedFrame_read);
    DELETE_DEVSTRING_ATTRIBUTE(attr_cameraModel_read);
    DELETE_DEVSTRING_ATTRIBUTE(attr_dllVersion_read);
    DELETE_SCALAR_ATTRIBUTE(attr_sensorTemperature_read);

    //- For dyn attr
    DELETE_SCALAR_ATTRIBUTE(attr_maxNbImage_read);
    DELETE_SCALAR_ATTRIBUTE(attr_cdiMode_read);
    DELETE_SCALAR_ATTRIBUTE(attr_frameRate_read);
    DELETE_SCALAR_ATTRIBUTE(attr_coolingSetPoint_read);
    DELETE_SCALAR_ATTRIBUTE(attr_adcOperation_read);
    DELETE_DEVSTRING_ATTRIBUTE(attr_shutterMode_read);

    //!!!! ONLY LimaDetector device can do this !!!!
    //if(m_ct!=0)
    //{
    //    ControlFactory::instance().reset("Pco");
    //    m_ct = 0;
    //}
}

//+----------------------------------------------------------------------------
//
// method : 		Pco::init_device()
// 
// description : 	will be called at device initialization.
//
//-----------------------------------------------------------------------------
void Pco::init_device()
{
    INFO_STREAM << "Pco::Pco() create device " << device_name << endl;

    // Initialise variables to default values
    //--------------------------------------------
    get_device_property();

    CREATE_DEVSTRING_ATTRIBUTE(attr_pixelRate_read, MAX_ATTRIBUTE_STRING_LENGTH);
    CREATE_SCALAR_ATTRIBUTE(attr_doubleImage_read);
    CREATE_SCALAR_ATTRIBUTE(attr_currentRecordedFrame_read);
    CREATE_DEVSTRING_ATTRIBUTE(attr_cameraModel_read, MAX_ATTRIBUTE_STRING_LENGTH);
    CREATE_DEVSTRING_ATTRIBUTE(attr_dllVersion_read, MAX_ATTRIBUTE_STRING_LENGTH);
    CREATE_SCALAR_ATTRIBUTE(attr_sensorTemperature_read);

    
    //- For dyn attr
    CREATE_SCALAR_ATTRIBUTE(attr_maxNbImage_read); 
    CREATE_SCALAR_ATTRIBUTE(attr_cdiMode_read);
    CREATE_SCALAR_ATTRIBUTE(attr_frameRate_read);
    CREATE_SCALAR_ATTRIBUTE(attr_coolingSetPoint_read);
    CREATE_DEVSTRING_ATTRIBUTE(attr_adcOperation_read, MAX_ATTRIBUTE_STRING_LENGTH);
    CREATE_DEVSTRING_ATTRIBUTE(attr_shutterMode_read, MAX_ATTRIBUTE_STRING_LENGTH);

   
    m_is_device_initialized = false;
    strcpy(*attr_pixelRate_read, "Not Initialised");
    m_camera_model = "Not Initialised";
    m_dll_version = "Not Initialised";
    set_state(Tango::INIT);
    m_status_message.str("");

    try
    {
        //- initialize Lima camera
        //- get the main object used to pilot the lima framework
        m_ct = ControlFactory::instance().get_control("Pco");

        //- get interface to specific camera
        m_hw = dynamic_cast<lima::Pco::Interface*>(m_ct->hwInterface());

        //- get camera to specific detector
        m_camera = (m_hw->getCamera());

        //- 
        m_camera->getCameraNameBase(m_camera_model);
        INFO_STREAM << "Camera model : " << m_camera_model << endl;
        //- 
        m_camera->getSdkRelease(m_dll_version);
        INFO_STREAM << "DLL version : " << m_dll_version << endl;

        //- Create dynamic interface
        create_dynamic_interface();

    }
    catch(lima::Exception& e)
    {
        m_status_message << "Initialization Failed : " << e.getErrMsg() << endl;
        ERROR_STREAM << m_status_message << endl;
        return;
    }
    catch (yat::Exception& ex)
    {
        m_status_message << "Initialization Failed : " << ex.errors[0].desc << endl;
        ERROR_STREAM << m_status_message << endl;
        return;
    }
    catch (Tango::DevFailed& df)
    {
        m_status_message << "Initialization Failed : " << df.errors[0].desc << endl;
        ERROR_STREAM << m_status_message << endl;
        return;
    }
    catch(...)
    {
        m_status_message << "Initialization Failed : Unknown error" << endl;
        ERROR_STREAM << m_status_message << endl;
        return;
    }

    m_is_device_initialized = true;
    dev_state();
}

//+----------------------------------------------------------------------------
//
// method : 		Pco::get_device_property()
// 
// description : 	Read the device properties from database.
//
//-----------------------------------------------------------------------------
void Pco::get_device_property()
{
    //	Initialize your default values here (if not done with  POGO).
    //------------------------------------------------------------------

    //	Read device properties from database.(Automatic code generation)
    //------------------------------------------------------------------
	

	//	Call database and extract values
	//--------------------------------------------


    //	End of Automatic code generation
    //------------------------------------------------------------------
}

/*-------------------------------------------------------------------------
//       Pco::create_dynamic_interface
/-------------------------------------------------------------------------*/
void Pco::create_dynamic_interface()
{
    DEBUG_STREAM << "Pco::create_dynamic_interface(): entering... !" << endl;
    try
    {
        if (m_camera_model.find("pco.dimax") != string::npos)
        {
            //create maxNbImage dyn attribute
            create_attribute("maxNbImage",
                Tango::DEV_ULONG,
                Tango::SCALAR,
                Tango::READ,
                Tango::OPERATOR,
                " ",
                "%d",
                "get the max number of images available in the Camera RAM",
                "Max Nb Image",
                NOT_MEMORIZED,
                NOT_WRITE_MEMORIZED_AT_INIT,
                &Pco::read_maxNbImage_callback,
                &Pco::write_callback_null);

            //create cdiMode dyn attribute
            create_attribute("cdiMode",
                Tango::DEV_BOOLEAN,
                Tango::SCALAR,
                Tango::READ_WRITE,
                Tango::OPERATOR,
                " ",
                "%1d",
                "enable / disable the cdi mode",
                "CDI mode",
                MEMORIZED,
                WRITE_MEMORIZED_AT_INIT,
                &Pco::read_cdiMode_callback,
                &Pco::write_cdiMode_callback);

            //create frameRate dyn attribute
            create_attribute("frameRate",
                Tango::DEV_DOUBLE,
                Tango::SCALAR,
                Tango::READ,
                Tango::OPERATOR,
                "fps",
                "%d",
                "get the frame rate",
                "Frame Rate",
                NOT_MEMORIZED,
                NOT_WRITE_MEMORIZED_AT_INIT,
                &Pco::read_frameRate_callback,
                &Pco::write_callback_null);
        }
        else if ((m_camera_model.find("pco.4000") != string::npos) ||
                 (m_camera_model.find("pco.2000") != string::npos) ||
                 (m_camera_model.find("pco.1600") != string::npos))
        {
            //create maxNbImage dyn attribute
            create_attribute("maxNbImage",
                Tango::DEV_ULONG,
                Tango::SCALAR,
                Tango::READ,
                Tango::OPERATOR,
                " ",
                "%d",
                "get the max number of images available in the Camera RAM",
                "Max Nb Image",
                NOT_MEMORIZED,
                NOT_WRITE_MEMORIZED_AT_INIT,
                &Pco::read_maxNbImage_callback,
                &Pco::write_callback_null);

            //create adcOperation dyn attribute
            create_attribute("adcOperation",
                Tango::DEV_STRING,
                Tango::SCALAR,
                Tango::READ_WRITE,
                Tango::OPERATOR,
                " ",
                "%1d",
                "set / get the adc operation: \nSINGLE\nDUAL",
                "ADC Operation",
                MEMORIZED,
                WRITE_MEMORIZED_AT_INIT,
                &Pco::read_adcOperation_callback,
                &Pco::write_adcOperation_callback);

            //create coolingSetPoint dyn attribute
            create_attribute("coolingSetPoint",
                Tango::DEV_DOUBLE,
                Tango::SCALAR,
                Tango::READ_WRITE,
                Tango::OPERATOR,
                "°C",
                "%6.2f",
                "set / get the cooling set point",
                "Cooling Set Point",
                MEMORIZED,
                NOT_WRITE_MEMORIZED_AT_INIT,
                &Pco::read_coolingSetPoint_callback,
                &Pco::write_coolingSetPoint_callback);

        }
        else if (m_camera_model.find("pco.edge") != string::npos) 
        {
            //create shutterMode dyn attribute
            create_attribute("shutterMode",
                Tango::DEV_STRING,
                Tango::SCALAR,
                Tango::READ_WRITE,
                Tango::OPERATOR,
                " ",
                " ",
                "set / get the shutterMode operation: \nROLLING_SHUTTER\nGLOBAL_SHUTTER\nGLOBAL_RESET",
                "Shutter Mode",
                MEMORIZED,
                WRITE_MEMORIZED_AT_INIT,
                &Pco::read_shutterMode_callback,
                &Pco::write_shutterMode_callback);

            //create frameRate dyn attribute
            create_attribute("frameRate",
                Tango::DEV_DOUBLE,
                Tango::SCALAR,
                Tango::READ,
                Tango::OPERATOR,
                "fps",
                "%d",
                "The frame rate",
                "Frame Rate",
                NOT_MEMORIZED,
                NOT_WRITE_MEMORIZED_AT_INIT,
                &Pco::read_frameRate_callback,
                &Pco::write_callback_null);

            //create coolingSetPoint dyn attribute
            create_attribute("coolingSetPoint",
                Tango::DEV_DOUBLE,
                Tango::SCALAR,
                Tango::READ_WRITE,
                Tango::OPERATOR,
                "°C",
                "%6.2f",
                "set / get the cooling set point",
                "Cooling Set Point",
                MEMORIZED,
                NOT_WRITE_MEMORIZED_AT_INIT,
                &Pco::read_coolingSetPoint_callback,
                &Pco::write_coolingSetPoint_callback);
        }
    }
    catch (yat::Exception& ex)
    {
        THROW_YAT_TO_TANGO_EXCEPTION(ex);
    }
    catch (Tango::DevFailed& df)
    {
        ERROR_STREAM << df << endl;

        //- rethrow exception
        Tango::Except::re_throw_exception(df,
                                        "TANGO_DEVICE_ERROR",
                                        string(df.errors[0].desc).c_str(),
                                        "Pco::create_dynamic_interface()");
    }
}

//+----------------------------------------------------------------------------
//
// method : 		Pco::always_executed_hook()
// 
// description : 	method always executed before any command is executed
//
//-----------------------------------------------------------------------------
void Pco::always_executed_hook()
{
    DEBUG_STREAM << "Pco::always_executed_hook() entering... "<< endl;

    try
    {
        m_is_device_initialized = false;

        yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());
        m_status_message.str("");
        //- get the singleton control objet used to pilot the lima framework
        m_ct = ControlFactory::instance().get_control("Pco");

        //- get interface to specific camera
        m_hw = dynamic_cast<lima::Pco::Interface*>(m_ct->hwInterface());

        //- get camera to specific detector
        m_camera = (m_hw->getCamera());

    }
    catch(lima::Exception& e)
    {
        m_status_message << "Initialization Failed : " << e.getErrMsg() << endl;
        ERROR_STREAM << m_status_message << endl;
        return;
    }
    catch(Tango::DevFailed& df)
    {
        m_status_message << "Initialization Failed : " << string(df.errors[0].desc) << endl;
        ERROR_STREAM << m_status_message << endl;
        return;
    }
    catch(...)
    {
        m_status_message << "Initialization Failed : Unknown error" << endl;
        ERROR_STREAM << m_status_message << endl;
        return;
    }

    m_is_device_initialized = true;
    //- update state
    dev_state();
}
//+----------------------------------------------------------------------------
//
// method : 		Pco::read_attr_hardware
// 
// description : 	Hardware acquisition for attributes.
//
//-----------------------------------------------------------------------------
void Pco::read_attr_hardware(vector<long> &attr_list)
{
    DEBUG_STREAM << "Pco::read_attr_hardware(vector<long> &attr_list) entering... "<< endl;
    //	Add your own code here
}
//+----------------------------------------------------------------------------
//
// method : 		Pco::read_currentRecordedFrame
// 
// description : 	Extract real attribute values for currentRecordedFrame acquisition result.
//
//-----------------------------------------------------------------------------
void Pco::read_currentRecordedFrame(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Pco::read_currentRecordedFrame(Tango::Attribute &attr) entering... "<< endl;

    try
    {
        m_camera->getLastImgRecorded(*attr_currentRecordedFrame_read);
        attr.set_value(attr_currentRecordedFrame_read);
    }
    catch (lima::Exception& e)
    {
        ERROR_STREAM << e.getErrMsg() << endl;
        //- throw exception
        Tango::Except::throw_exception(
            "LIMA_ERROR",
            e.getErrMsg().c_str(),
            "Pco::read_currentRecordedFrame");
    }
}

//+----------------------------------------------------------------------------
//
// method : 		Pco::read_doubleImage
// 
// description : 	Extract real attribute values for doubleImage acquisition result.
//
//-----------------------------------------------------------------------------
void Pco::read_doubleImage(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Pco::read_doubleImage(Tango::Attribute &attr) entering... "<< endl;

    //- throw exception
    Tango::Except::throw_exception(
        "LIMA_ERROR",
        "doubleImage is not yet supported",
        "Pco::read_doubleImage");
}

//+----------------------------------------------------------------------------
//
// method : 		Pco::write_doubleImage
// 
// description : 	Write doubleImage attribute values to hardware.
//
//-----------------------------------------------------------------------------
void Pco::write_doubleImage(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "Pco::write_doubleImage(Tango::WAttribute &attr) entering... "<< endl;

    //- throw exception
    Tango::Except::throw_exception(
        "LIMA_ERROR",
        "doubleImage is not yet supported",
        "Pco::write_doubleImage");
}

//+----------------------------------------------------------------------------
//
// method : 		Pco::read_sensorTemperature
// 
// description : 	Extract real attribute values for sensorTemperature acquisition result.
//
//-----------------------------------------------------------------------------
void Pco::read_sensorTemperature(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Pco::read_sensorTemperature(Tango::Attribute &attr) entering... "<< endl;

    try
    {
        std::string temp_temperature_info,temp_temperature;
        m_camera->getTemperatureInfo(temp_temperature_info);
        yat::StringUtil::extract_token(&temp_temperature_info, '[', ']', &temp_temperature);
        *attr_sensorTemperature_read = yat::StringUtil::to_num<float>(temp_temperature);
        attr.set_value(attr_sensorTemperature_read);
    }
    catch (lima::Exception& e)
    {
        ERROR_STREAM << e.getErrMsg() << endl;
        //- throw exception
        Tango::Except::throw_exception(
                                        "LIMA_ERROR",
                                        e.getErrMsg().c_str(),
                                        "Pco::read_sensorTemperature");
    }
}

//+----------------------------------------------------------------------------
//
// method :         Pco::read_maxNbImage_callback()
//
// description : Extract real attribute values for maxNbImage
//
//-----------------------------------------------------------------------------
void Pco::read_maxNbImage_callback(yat4tango::DynamicAttributeReadCallbackData& cbd)
{
    DEBUG_STREAM << "Pco::read_maxNbImage_callback()" << endl; //  << cbd.dya->get_name() << endl;

    try
    {
        m_camera->getMaxNbImages(*attr_maxNbImage_read);
        cbd.tga->set_value(attr_maxNbImage_read);
    }
    catch (lima::Exception& e)
    {
        ERROR_STREAM << e.getErrMsg() << endl;
        //- throw exception
        Tango::Except::throw_exception(
            "LIMA_ERROR",
            e.getErrMsg().c_str(),
            "Pco::read_maxNbImage_callback");
    }
}

//+----------------------------------------------------------------------------
//
// method :         Pco::read_cdiMode_callback()
//
// description : Extract real attribute values for cdi
//
//-----------------------------------------------------------------------------
void Pco::read_cdiMode_callback(yat4tango::DynamicAttributeReadCallbackData& cbd)
{
    DEBUG_STREAM << "Pco::read_cdiMode_callback()" << endl; //  << cbd.dya->get_name() << endl;

    try
    {
        int cdi_mode_temp = -1;
        m_camera->getCDIMode(cdi_mode_temp);
        *attr_cdiMode_read = cdi_mode_temp;
        cbd.tga->set_value(attr_cdiMode_read);
    }
    catch (lima::Exception& e)
    {
        ERROR_STREAM << e.getErrMsg() << endl;
        //- throw exception
        Tango::Except::throw_exception(
                                        "LIMA_ERROR",
                                        e.getErrMsg().c_str(),
                                        "Pco::read_cdiMode_callback");
    }
}

//+----------------------------------------------------------------------------
//
// method : 		Pco::is_cdiMode_allowed
// 
// description : 	Read/Write allowed for cdiMode attribute.
//
//-----------------------------------------------------------------------------
bool Pco::is_cdiMode_allowed(Tango::AttReqType type)
{
    INFO_STREAM << "Pco::is_cdiMode_allowed" << endl;
    if (get_state() == Tango::INIT ||
        get_state() == Tango::FAULT ||
        get_state() == Tango::RUNNING)
    {
        //	End of Generated Code

        if ((get_state() == Tango::RUNNING) && (Tango::READ_REQ == type))
        {
            return true;
        }

        //	Re-Start of Generated Code
        return false;
    }
    return true;
}

//+----------------------------------------------------------------------------
//
// method :         Pco::write_cdiMode_callback()
//
// description : Extract real attribute values for cdi
//
//-----------------------------------------------------------------------------
void Pco::write_cdiMode_callback(yat4tango::DynamicAttributeWriteCallbackData& cbd)
{
    DEBUG_STREAM << "Pco::write_cdiMode_callback()" << endl; //  << cbd.dya->get_name() << endl;

    try
    {
        cbd.tga->get_write_value(attr_cdiMode_write);
        m_camera->setCDIMode(attr_cdiMode_write);
    }
    catch (lima::Exception& e)
    {
        ERROR_STREAM << e.getErrMsg() << endl;
        //- throw exception
        Tango::Except::throw_exception(
                                        "LIMA_ERROR",
                                        e.getErrMsg().c_str(),
                                        "Pco::write_cdiMode_callback");
    }
}

//+----------------------------------------------------------------------------
//
// method :         Pco::read_frameRate_callback()
//
// description : Extract real attribute values for frameRate
//
//-----------------------------------------------------------------------------
void Pco::read_frameRate_callback(yat4tango::DynamicAttributeReadCallbackData& cbd)
{
    DEBUG_STREAM << "Pco::read_frameRate_callback()" << endl; //  << cbd.dya->get_name() << endl;

    try
    {
        m_camera->getFrameRate(*attr_frameRate_read);
        cbd.tga->set_value(attr_frameRate_read);
    }
    catch (lima::Exception& e)
    {
        ERROR_STREAM << e.getErrMsg() << endl;
        //- throw exception
        Tango::Except::throw_exception(
            "LIMA_ERROR",
            e.getErrMsg().c_str(),
            "Pco::read_frameRate_callback");
    }
}

//+----------------------------------------------------------------------------
//
// method :         Pco::read_coolingSetPoint_callback()
//
// description : Extract real attribute values for coolingSetPoint
//
//-----------------------------------------------------------------------------
void Pco::read_coolingSetPoint_callback(yat4tango::DynamicAttributeReadCallbackData& cbd)
{
    DEBUG_STREAM << "Pco::read_coolingSetPoint_callback()" << endl; //  << cbd.dya->get_name() << endl;

    try
    {
        m_camera->getCoolingTemperature((int&)*attr_coolingSetPoint_read);
        cbd.tga->set_value(attr_coolingSetPoint_read);
    }
    catch (lima::Exception& e)
    {
        ERROR_STREAM << e.getErrMsg() << endl;
        //- throw exception
        Tango::Except::throw_exception(
            "LIMA_ERROR",
            e.getErrMsg().c_str(),
            "Pco::read_coolingSetPoint_callback");
    }
}

//+----------------------------------------------------------------------------
//
// method :         Pco::write_coolingSetPoint_callback()
//
// description : Extract real attribute values for coolingSetPoint
//
//-----------------------------------------------------------------------------
void Pco::write_coolingSetPoint_callback(yat4tango::DynamicAttributeWriteCallbackData& cbd)
{
    DEBUG_STREAM << "Pco::write_coolingSetPoint_callback()" << endl; //  << cbd.dya->get_name() << endl;

    try
    {
        cbd.tga->get_write_value(attr_coolingSetPoint_write);
        m_camera->setCoolingTemperature(attr_coolingSetPoint_write);
    }
    catch (lima::Exception& e)
    {
        ERROR_STREAM << e.getErrMsg() << endl;
        //- throw exception
        Tango::Except::throw_exception(
            "LIMA_ERROR",
            e.getErrMsg().c_str(),
            "Pco::write_coolingSetPoint_callback");
    }
}

//+----------------------------------------------------------------------------
//
// method :         Pco::read_adcOperation_callback()
//
// description : Extract real attribute values for adcOperation
//
//-----------------------------------------------------------------------------
void Pco::read_adcOperation_callback(yat4tango::DynamicAttributeReadCallbackData& cbd)
{
    DEBUG_STREAM << "Pco::read_adcOperation_callback()" << endl; //  << cbd.dya->get_name() << endl;

    try
    {
        int adc_temp = -1;
        m_camera->getAdc(adc_temp);
        switch (adc_temp)
        {
            case 1:
                strcpy(*attr_adcOperation_read, "SINGLE");
                break;
            case 2:
                strcpy(*attr_adcOperation_read, "DUAL");
                break;
            default:
                strcpy(*attr_adcOperation_read, "UNKNOWN");
                break;
        }

        cbd.tga->set_value(attr_adcOperation_read);
    }
    catch (lima::Exception& e)
    {
        ERROR_STREAM << e.getErrMsg() << endl;
        //- throw exception
        Tango::Except::throw_exception(
            "LIMA_ERROR",
            e.getErrMsg().c_str(),
            "Pco::read_adcOperation_callback");
    }
}

//+----------------------------------------------------------------------------
//
// method :         Pco::write_adcOperation_callback()
//
// description : Extract real attribute values for adcOperation
//
//-----------------------------------------------------------------------------
void Pco::write_adcOperation_callback(yat4tango::DynamicAttributeWriteCallbackData& cbd)
{
    DEBUG_STREAM << "Pco::write_adcOperation_callback()" << endl; //  << cbd.dya->get_name() << endl;

    try
    {
        std::string previous = *attr_adcOperation_read;
        cbd.tga->get_write_value(attr_adcOperation_write);
        std::string current = attr_adcOperation_write;

        int value_to_write;
                
        if(current == "SINGLE")
            value_to_write = 1;
        else if(current == "DUAL")
            value_to_write = 2;
        else
            Tango::Except::throw_exception("CONFIGURATION_ERROR",
                                           "Available ADC values are: \n- SINGLE\n- DUAL" ,
                                           "Pco::write_adcOperation_callback");

        m_camera->setAdc(value_to_write);
    }
    catch (lima::Exception& e)
    {
        ERROR_STREAM << e.getErrMsg() << endl;
        //- throw exception
        Tango::Except::throw_exception(
            "LIMA_ERROR",
            e.getErrMsg().c_str(),
            "Pco::write_adcOperation_callback");
    }
}

//+----------------------------------------------------------------------------
//
// method : 		Pco::read_shutterMode_callback
// 
// description : 	Extract real attribute values for shutterMode acquisition result.
//
//-----------------------------------------------------------------------------
void Pco::read_shutterMode_callback(yat4tango::DynamicAttributeReadCallbackData& cbd)
{
    DEBUG_STREAM << "Pco::read_shutterMode_callback(Tango::Attribute &attr) entering... "<< endl;

    try
    {
        int shutter_temp = -1;
        m_camera->getRollingShutter(shutter_temp);
        switch (shutter_temp)
        {
        case 1:
            strcpy(*attr_shutterMode_read, "ROLLING_SHUTTER");
            break;
        case 2:
            strcpy(*attr_shutterMode_read, "GLOBAL_SHUTTER");
            break;
        case 4:
            strcpy(*attr_shutterMode_read, "GLOBAL_RESET");
            break;
        default:
            strcpy(*attr_shutterMode_read, "UNKNOWN");
            break;
        }

        cbd.tga->set_value(attr_shutterMode_read);
    }
    catch (lima::Exception& e)
    {
        ERROR_STREAM << e.getErrMsg() << endl;
        //- throw exception
        Tango::Except::throw_exception(
            "LIMA_ERROR",
            e.getErrMsg().c_str(),
            "Pco::read_shutterMode_callback");
    }
}

//+----------------------------------------------------------------------------
//
// method : 		Pco::write_shutterMode_callback
// 
// description : 	Write shutterMode attribute values to hardware.
//
//-----------------------------------------------------------------------------
void Pco::write_shutterMode_callback(yat4tango::DynamicAttributeWriteCallbackData& cbd)
{
    DEBUG_STREAM << "Pco::write_shutterMode_callback(Tango::WAttribute &attr) entering... "<< endl;

    try
    {
        std::string previous = *attr_shutterMode_read;
        cbd.tga->get_write_value(attr_shutterMode_write);
        std::string current = attr_shutterMode_write;

        int value_to_write;

        if (current == "ROLLING_SHUTTER")
            value_to_write = 1;
        else if (current == "GLOBAL_SHUTTER")
            value_to_write = 2;
        else if (current == "GLOBAL_RESET")
            value_to_write = 4;
        else
            Tango::Except::throw_exception( "CONFIGURATION_ERROR",
                                            "Available Shutter values are: \n- ROLLING_SHUTTER\n- GLOBAL_SHUTTER\n- GLOBAL_RESET",
                                            "Pco::write_shutterMode_callback");

        m_camera->setRollingShutter(value_to_write);
    }
    catch (lima::Exception& e)
    {
        ERROR_STREAM << e.getErrMsg() << endl;
        //- throw exception
        Tango::Except::throw_exception(
            "LIMA_ERROR",
            e.getErrMsg().c_str(),
            "Pco::write_shutterMode_callback");
    }
}

//+----------------------------------------------------------------------------
//
// method : 		Pco::read_pixelRate
// 
// description : 	Extract real attribute values for pixelRate acquisition result.
//
//-----------------------------------------------------------------------------
void Pco::read_pixelRate(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Pco::read_pixelRate(Tango::Attribute &attr) entering... "<< endl;

    try
    {
        int temp_pixel_rate = -1;
        m_camera->getPixelRate(temp_pixel_rate);
        std::string pixel_rate_str = yat::StringUtil::to_string<int>(temp_pixel_rate);
        strcpy(*attr_pixelRate_read, pixel_rate_str.c_str());
        attr.set_value(attr_pixelRate_read);
    }
    catch (yat::Exception& ex)
    {
        THROW_YAT_TO_TANGO_EXCEPTION(ex);
    }
    catch (lima::Exception& e)
    {
        ERROR_STREAM << e.getErrMsg() << endl;
        //- throw exception
        Tango::Except::throw_exception("LIMA_ERROR",
                                        e.getErrMsg().c_str(),
                                        "Pco::read_pixelRate");
    }
}

//+----------------------------------------------------------------------------
//
// method : 		Pco::write_pixelRate
// 
// description : 	Write pixelRate attribute values to hardware.
//
//-----------------------------------------------------------------------------
void Pco::write_pixelRate(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "Pco::write_pixelRate(Tango::WAttribute &attr) entering... "<< endl;

    try
    {
        std::string previous = *attr_pixelRate_read;
        attr.get_write_value(attr_pixelRate_write);
        std::string current = attr_pixelRate_write;

        std::string pixel_rate_valid_values;
        m_camera->getPixelRateValidValues(pixel_rate_valid_values);
        if (pixel_rate_valid_values.find(current) == std::string::npos)
            Tango::Except::throw_exception( "CONFIGURATION_ERROR",
                                            "Available pixelRate values are:\n" + pixel_rate_valid_values,
                                            "Pco::write_shutterMode_callback");
     
        int value_to_write = yat::StringUtil::to_num<int>(std::string(attr_pixelRate_write));
        m_camera->setPixelRate(value_to_write);
    }
    catch (yat::Exception& ex)
    {
        THROW_YAT_TO_TANGO_EXCEPTION(ex);
    }
    catch (lima::Exception& e)
    {
        ERROR_STREAM << e.getErrMsg() << endl;
        //- throw exception
        Tango::Except::throw_exception("LIMA_ERROR",
                                        e.getErrMsg().c_str(),
                                        "Pco::write_pixelScanRate");
    }
}

//+----------------------------------------------------------------------------
//
// method : 		Pco::read_cameraModel
// 
// description : 	Extract real attribute values for cameraModel acquisition result.
//
//-----------------------------------------------------------------------------
void Pco::read_cameraModel(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Pco::read_cameraModel(Tango::Attribute &attr) entering... "<< endl;

    try
    {
        strcpy(*attr_cameraModel_read, m_camera_model.c_str());
        attr.set_value(attr_cameraModel_read);
    }
    catch (yat::Exception& ex)
    {
        THROW_YAT_TO_TANGO_EXCEPTION(ex);
    }
    catch (lima::Exception& e)
    {
        ERROR_STREAM << e.getErrMsg() << endl;
        //- throw exception
        Tango::Except::throw_exception(
                                    "LIMA_ERROR",
                                    e.getErrMsg().c_str(),
                                    "Pco::read_cameraModel");
    }
}

//+----------------------------------------------------------------------------
//
// method : 		Pco::read_dllVersion
// 
// description : 	Extract real attribute values for dllVersion acquisition result.
//
//-----------------------------------------------------------------------------
void Pco::read_dllVersion(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Pco::read_dllVersion(Tango::Attribute &attr) entering... "<< endl;

    try
    {
        strcpy(*attr_dllVersion_read, m_dll_version.c_str());
        attr.set_value(attr_dllVersion_read);
    }
    catch (yat::Exception& ex)
    {
        THROW_YAT_TO_TANGO_EXCEPTION(ex);
    }
    catch (lima::Exception& e)
    {
        ERROR_STREAM << e.getErrMsg() << endl;
        //- throw exception
        Tango::Except::throw_exception(
            "LIMA_ERROR",
            e.getErrMsg().c_str(),
            "Pco::read_dllVersion");
    }
}

//+------------------------------------------------------------------
/**
 *	method:	Pco::talk
 *
 *	description:	method to execute "Talk"
 *	Availables values are:<br>
 *	lasterror<br>
 *	camInfo<br>
 *	camType<br>
 *	clTransferParam<br>
 *	cocRunTime<br>
 *	frameRate<br>
 *	maxNbImages<br>
 *	timestamp<br>
 *	" "<br>
 *
 * @param	argin	str argin
 * @return	str argout
 *
 */
//+------------------------------------------------------------------
Tango::DevString Pco::talk(Tango::DevString argin)
{
    //	POGO has generated a method core with argout allocation.
    //	If you would like to use a static reference without copying,
    //	See "TANGO Device Server Programmer's Manual"
    //		(chapter : Writing a TANGO DS / Exchanging data)
    //------------------------------------------------------------
    Tango::DevString	argout  = new char[MAX_ATTRIBUTE_STRING_LENGTH];
    strcpy(argout, "dummy");
    DEBUG_STREAM << "Pco::talk(): entering... !" << endl;

    //	Add your own code to control device here
    try
    {
        argout = const_cast<char*>(m_camera->talk(const_cast<char*>(argin)));
        return argout;
    }
    catch(lima::Exception& e)
    {
        ERROR_STREAM << e.getErrMsg() << endl;
        //- throw exception
        Tango::Except::throw_exception("LIMA_ERROR",
                                       e.getErrMsg().c_str(),
                                       "Pco::talk");
    }
}

//+------------------------------------------------------------------
/**
 *	method:	Pco::get_cam_info
 *
 *	description:	method to execute "GetCamInfo"
 *	Get Camera Infos
 *
 * @return	cam infos
 *
 */
//+------------------------------------------------------------------
Tango::DevString Pco::get_cam_info()
{
    //	POGO has generated a method core with argout allocation.
    //	If you would like to use a static reference without copying,
    //	See "TANGO Device Server Programmer's Manual"
    //		(chapter : Writing a TANGO DS / Exchanging data)
    //------------------------------------------------------------
    Tango::DevString	argout  = new char[MAX_ATTRIBUTE_STRING_LENGTH];
    strcpy(argout, "dummy");
    DEBUG_STREAM << "Pco::get_cam_info(): entering... !" << endl;

    //	Add your own code to control device here
    try
    {
        argout = const_cast<char*>(m_camera->talk("camInfo"));
        return argout;
    }
    catch(lima::Exception& e)
    {
        ERROR_STREAM << e.getErrMsg() << endl;
        //- throw exception
        Tango::Except::throw_exception("LIMA_ERROR",
                                       e.getErrMsg().c_str(),
                                       "Pco::get_cam_info");
    }    
}

//+------------------------------------------------------------------
/**
 *	method:	Pco::dev_state
 *
 *	description:	method to execute "State"
 *	This command gets the device state (stored in its <i>device_state</i> data member) and returns it to the caller.
 *
 * @return	State Code
 *
 */
//+------------------------------------------------------------------
Tango::DevState Pco::dev_state()
{
    Tango::DevState	argout = DeviceImpl::dev_state();
    DEBUG_STREAM << "Pco::dev_state(): entering... !" << endl;

    //	Add your own code to control device here

    stringstream DeviceStatus;
    DeviceStatus.str("");
    Tango::DevState DeviceState = Tango::STANDBY;

    //if error during init_device
    if(!m_is_device_initialized)
    {
        DeviceState = Tango::FAULT;
        DeviceStatus << m_status_message.str();
        DeviceStatus << endl;
    }
    else
    {
        // let's take a look at the status of control & the status of the plugin        
        DeviceState = ControlFactory::instance().get_state();
        DeviceStatus << ControlFactory::instance().get_status();
    }

    set_state(DeviceState);
    set_status(DeviceStatus.str());

    argout = DeviceState;
    return argout;
}







}	//	namespace
