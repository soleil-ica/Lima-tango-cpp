static const char *RcsId = "$Id:  $";
//+=============================================================================
//
// file :         ImXpad.cpp
//
// description :  C++ source for the ImXpad and its commands. 
//                The class is derived from Device. It represents the
//                CORBA servant object which will be accessed from the
//                network. All commands which can be executed on the
//                ImXpad are implemented in this file.
//
// project :      TANGO Device Server
//
// $Author:  $
//
// $Revision:  $
//
// $Revision:  $
// $Date:  $
//
// SVN only:
// $HeadURL: $
//
// CVS only:
// $Source:  $
// $Log:  $
//
// copyleft :    Synchrotron SOLEIL 
//               L'Orme des merisiers - Saint Aubin
//               BP48 - 91192 Gif sur Yvette
//               FRANCE
//
//-=============================================================================
//
//  		This file is generated by POGO
//	(Program Obviously used to Generate tango Object)
//
//         (c) - Software Engineering Group - ESRF
//=============================================================================



//===================================================================
//
//	The following table gives the correspondence
//	between commands and method name.
//
//  Command name         |  Method name
//	----------------------------------------
//  State                |  dev_state()
//  Status               |  dev_status()
//  StartCalibration     |  start_calibration()
//  SaveCalibrationFile  |  save_calibration_file()
//  LoadCalibrationFile  |  load_calibration_file()
//  CreateWhiteImage     |  create_white_image()
//  ChooseWhiteImage     |  choose_white_image()
//  GetWhiteImagesList   |  get_white_images_list()
//  DeleteWhiteImage     |  delete_white_image()
//  Abort                |  abort()
//  ITHLIncrease         |  ithlincrease()
//  ITHLDecrease         |  ithldecrease()
//
//===================================================================


#include <tango.h>
#include <PogoHelper.h>
#include <ImXpad.h>
#include <ImXpadClass.h>

#include <yat/file/FileName.h>

//-----------------------------------------------------
//
//-----------------------------------------------------
inline void _split(const std::string inString, const std::string &separator, std::vector<std::string> &returnVector)
{
    std::string::size_type start = 0;
    std::string::size_type end = 0;

    while ((end = inString.find (separator, start)) != std::string::npos)
    {
        returnVector.push_back (inString.substr (start, end - start));
        start = end + separator.size();
    }

    returnVector.push_back (inString.substr (start));
}
//-----------------------------------------------------


namespace ImXpad_ns
{

//+----------------------------------------------------------------------------
//
// method : 		ImXpad::ImXpad(string &s)
// 
// description : 	constructor for simulated ImXpad
//
// in : - cl : Pointer to the DeviceClass object
//      - s : Device name 
//
//-----------------------------------------------------------------------------
ImXpad::ImXpad(Tango::DeviceClass *cl, string &s)
:Tango::Device_4Impl(cl, s.c_str())
{
    init_device();
}
ImXpad::ImXpad(Tango::DeviceClass *cl, const char *s)
:Tango::Device_4Impl(cl, s)
{
    init_device();
}
ImXpad::ImXpad(Tango::DeviceClass *cl, const char *s, const char *d)
:Tango::Device_4Impl(cl, s, d)
{
    init_device();
}
//+----------------------------------------------------------------------------
//
// method : 		ImXpad::delete_device()
// 
// description : 	will be called at device destruction or at init command.
//
//-----------------------------------------------------------------------------
void ImXpad::delete_device()
{
    DELETE_DEVSTRING_ATTRIBUTE(attr_serverVersion_read);
    DELETE_DEVSTRING_ATTRIBUTE(attr_calibrationFileName_read);
    DELETE_DEVSTRING_ATTRIBUTE(attr_acquisitionMode_read);
    DELETE_DEVSTRING_ATTRIBUTE(attr_outputSignal_read);

	DELETE_SCALAR_ATTRIBUTE(attr_flatFieldCorrectionFlag_read);
	DELETE_SCALAR_ATTRIBUTE(attr_geometricalCorrectionFlag_read);

    DELETE_DEVSTRING_ATTRIBUTE(attr_calibrationPath_read);

    INFO_STREAM << "Remove the inner-appender." << endl;
    yat4tango::InnerAppender::release(this);

    //	Delete device allocated objects
    
    //!!!! ONLY LimaDetector device can do this !!!!
    //if(m_ct!=0)
    //{
    //    ControlFactory::instance().reset("ImXpad");
    //    m_ct = 0;
    //}    
}

//+----------------------------------------------------------------------------
//
// method : 		ImXpad::init_device()
// 
// description : 	will be called at device initialization.
//
//-----------------------------------------------------------------------------
void ImXpad::init_device()
{
    INFO_STREAM << "ImXpad::ImXpad() create device " << device_name << endl;

    // Initialise variables to default values
    //--------------------------------------------
    get_device_property();
    
    CREATE_DEVSTRING_ATTRIBUTE(attr_serverVersion_read, MAX_ATTRIBUTE_STRING_LENGTH);
    CREATE_DEVSTRING_ATTRIBUTE(attr_calibrationFileName_read, MAX_ATTRIBUTE_STRING_LENGTH);
    CREATE_DEVSTRING_ATTRIBUTE(attr_acquisitionMode_read, MAX_ATTRIBUTE_STRING_LENGTH);
    CREATE_DEVSTRING_ATTRIBUTE(attr_outputSignal_read, MAX_ATTRIBUTE_STRING_LENGTH);
	CREATE_SCALAR_ATTRIBUTE(attr_flatFieldCorrectionFlag_read);
	CREATE_SCALAR_ATTRIBUTE(attr_geometricalCorrectionFlag_read);
    CREATE_DEVSTRING_ATTRIBUTE(attr_calibrationPath_read, MAX_ATTRIBUTE_STRING_LENGTH);
    
    m_is_device_initialized = false;
	attr_calibrationMode_write ="OTN_PULSE";	
    set_state(Tango::INIT);
    m_status_message.str("");

    INFO_STREAM << "Create the inner-appender in order to manage logs." << endl;  
    yat4tango::InnerAppender::initialize(this, 512);

    try
    {
        //- get the main object used to pilot the lima framework
        //in fact LimaDetector is create the singleton control objet
        //so this call, will only return existing object, no need to give it the ip !!
        m_ct = ControlFactory::instance().get_control("ImXpad");

        //- get interface to specific camera
        m_hw = dynamic_cast<imXpad::Interface*> (m_ct->hwInterface());

        //- get camera to specific detector
        m_camera = &(m_hw->getCamera());
    }
    catch (Exception& e)
    {
        INFO_STREAM << "Initialization Failed : " << e.getErrMsg() << endl;
        m_status_message << "Initialization Failed : " << e.getErrMsg() << endl;
        m_is_device_initialized = false;
        set_state(Tango::FAULT);
        return;
    }
    catch (...)
    {
        INFO_STREAM << "Initialization Failed : UNKNOWN" << endl;
        m_status_message << "Initialization Failed : UNKNOWN" << endl;
        set_state(Tango::FAULT);
        m_is_device_initialized = false;
        return;
    }

    m_is_device_initialized = true;
	try
	{
    	Tango::WAttribute &calibrationMode = dev_attr->get_w_attr_by_name("calibrationMode");
    	m_calibration_mode = memorizedCalibrationMode;
    	attr_calibrationMode_write = const_cast<Tango::DevString>(memorizedCalibrationMode.c_str());
    	calibrationMode.set_write_value(attr_calibrationMode_write);
    	write_calibrationMode(calibrationMode);

    	Tango::WAttribute &mode = dev_attr->get_w_attr_by_name("calibrationConfigMode");
    	m_mode = memorizedMode;
    	attr_calibrationConfigMode_write = const_cast<Tango::DevString>(memorizedMode.c_str());
    	mode.set_write_value(attr_calibrationConfigMode_write);
    	write_calibrationConfigMode(mode);
		
    	Tango::WAttribute &time = dev_attr->get_w_attr_by_name("calibrationExposureTime");
    	attr_calibrationExposureTime_write = memorizedTime;
    	time.set_write_value(attr_calibrationExposureTime_write);
    	write_calibrationExposureTime(time);

    	Tango::WAttribute &iTHL = dev_attr->get_w_attr_by_name("calibrationBeamITHL");
    	attr_CalibrationBeamITHL_write = memorizedITHL;
    	iTHL.set_write_value(attr_CalibrationBeamITHL_write);
    	write_CalibrationBeamITHL(iTHL);

    	Tango::WAttribute &nbStackingImages = dev_attr->get_w_attr_by_name("nbStackingImages");
    	attr_nbStackingImages_write = memorizedNbStackingImages;
    	nbStackingImages.set_write_value(attr_nbStackingImages_write);
    	write_nbStackingImages(nbStackingImages);
		
    	Tango::WAttribute &geometrical = dev_attr->get_w_attr_by_name("geometricalCorrectionFlag");
    	*attr_geometricalCorrectionFlag_read = attr_geometricalCorrectionFlag_write = memorizedGeometricalCorrectionFlag;
    	geometrical.set_write_value(attr_geometricalCorrectionFlag_write);
    	write_geometricalCorrectionFlag(geometrical);

    	Tango::WAttribute &flatField = dev_attr->get_w_attr_by_name("flatFieldCorrectionFlag");
    	*attr_flatFieldCorrectionFlag_read = attr_flatFieldCorrectionFlag_write = memorizedFlatFieldCorrectionFlag;
    	flatField.set_write_value(attr_flatFieldCorrectionFlag_write);
    	write_flatFieldCorrectionFlag(flatField);

        Tango::WAttribute &acquisitionMode = dev_attr->get_w_attr_by_name("acquisitionMode");
        m_acquisition_mode = memorizedAcquisitionMode;
        attr_acquisitionMode_write = const_cast<Tango::DevString>(memorizedAcquisitionMode.c_str());
        acquisitionMode.set_write_value(attr_acquisitionMode_write);
        write_acquisitionMode(acquisitionMode);

        Tango::WAttribute &outputSignal = dev_attr->get_w_attr_by_name("outputSignal");
        m_output_signal = memorizedOutputSignal;
        attr_outputSignal_write = const_cast<Tango::DevString>(memorizedOutputSignal.c_str());
        outputSignal.set_write_value(attr_outputSignal_write);
        write_outputSignal(outputSignal);

        strcpy(*attr_calibrationPath_read, calibrationPath.c_str());
	}
    catch(Tango::DevFailed& df)
    {
        ERROR_STREAM << df << endl;
        m_status_message << "Initialization Failed : ";
        for(unsigned i = 0; i < df.errors.length(); i++)
        {
            m_status_message << df.errors[i].desc << endl;
        }
        m_is_device_initialized = false;
        set_state(Tango::FAULT);
        return;
    }
    catch(Exception& e)
    {
        ERROR_STREAM << "Initialization Failed : " << e.getErrMsg() << endl;
        m_status_message << "Initialization Failed : " << e.getErrMsg() << endl;
        m_is_device_initialized = false;
        set_state(Tango::FAULT);
        return;
    }

    set_state(Tango::STANDBY);
    dev_state();
}


//+----------------------------------------------------------------------------
//
// method : 		ImXpad::get_device_property()
// 
// description : 	Read the device properties from database.
//
//-----------------------------------------------------------------------------
void ImXpad::get_device_property()
{
    //	Initialize your default values here (if not done with  POGO).
    //------------------------------------------------------------------

    //	Read device properties from database.(Automatic code generation)
    //------------------------------------------------------------------
	Tango::DbData	dev_prop;
	dev_prop.push_back(Tango::DbDatum("HostName"));
	dev_prop.push_back(Tango::DbDatum("Port"));
	dev_prop.push_back(Tango::DbDatum("CalibrationPath"));
	dev_prop.push_back(Tango::DbDatum("MemorizedGeometricalCorrectionFlag"));
	dev_prop.push_back(Tango::DbDatum("MemorizedFlatFieldCorrectionFlag"));
	dev_prop.push_back(Tango::DbDatum("MemorizedAcquisitionMode"));
	dev_prop.push_back(Tango::DbDatum("MemorizedOutputSignal"));
	dev_prop.push_back(Tango::DbDatum("MemorizedCalibrationMode"));
	dev_prop.push_back(Tango::DbDatum("MemorizedMode"));
	dev_prop.push_back(Tango::DbDatum("MemorizedTime"));
	dev_prop.push_back(Tango::DbDatum("MemorizedITHL"));
	dev_prop.push_back(Tango::DbDatum("MemorizedNbStackingImages"));
	dev_prop.push_back(Tango::DbDatum("ModuleMask"));

	//	Call database and extract values
	//--------------------------------------------
	if (Tango::Util::instance()->_UseDb==true)
		get_db_device()->get_property(dev_prop);
	Tango::DbDatum	def_prop, cl_prop;
	ImXpadClass	*ds_class =
		(static_cast<ImXpadClass *>(get_device_class()));
	int	i = -1;

	//	Try to initialize HostName from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  hostName;
	else {
		//	Try to initialize HostName from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  hostName;
	}
	//	And try to extract HostName value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  hostName;

	//	Try to initialize Port from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  port;
	else {
		//	Try to initialize Port from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  port;
	}
	//	And try to extract Port value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  port;

	//	Try to initialize CalibrationPath from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  calibrationPath;
	else {
		//	Try to initialize CalibrationPath from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  calibrationPath;
	}
	//	And try to extract CalibrationPath value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  calibrationPath;

	//	Try to initialize MemorizedGeometricalCorrectionFlag from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  memorizedGeometricalCorrectionFlag;
	else {
		//	Try to initialize MemorizedGeometricalCorrectionFlag from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  memorizedGeometricalCorrectionFlag;
	}
	//	And try to extract MemorizedGeometricalCorrectionFlag value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  memorizedGeometricalCorrectionFlag;

	//	Try to initialize MemorizedFlatFieldCorrectionFlag from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  memorizedFlatFieldCorrectionFlag;
	else {
		//	Try to initialize MemorizedFlatFieldCorrectionFlag from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  memorizedFlatFieldCorrectionFlag;
	}
	//	And try to extract MemorizedFlatFieldCorrectionFlag value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  memorizedFlatFieldCorrectionFlag;

	//	Try to initialize MemorizedAcquisitionMode from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  memorizedAcquisitionMode;
	else {
		//	Try to initialize MemorizedAcquisitionMode from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  memorizedAcquisitionMode;
	}
	//	And try to extract MemorizedAcquisitionMode value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  memorizedAcquisitionMode;

	//	Try to initialize MemorizedOutputSignal from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  memorizedOutputSignal;
	else {
		//	Try to initialize MemorizedOutputSignal from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  memorizedOutputSignal;
	}
	//	And try to extract MemorizedOutputSignal value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  memorizedOutputSignal;

	//	Try to initialize MemorizedCalibrationMode from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  memorizedCalibrationMode;
	else {
		//	Try to initialize MemorizedCalibrationMode from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  memorizedCalibrationMode;
	}
	//	And try to extract MemorizedCalibrationMode value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  memorizedCalibrationMode;

	//	Try to initialize MemorizedMode from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  memorizedMode;
	else {
		//	Try to initialize MemorizedMode from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  memorizedMode;
	}
	//	And try to extract MemorizedMode value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  memorizedMode;

	//	Try to initialize MemorizedTime from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  memorizedTime;
	else {
		//	Try to initialize MemorizedTime from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  memorizedTime;
	}
	//	And try to extract MemorizedTime value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  memorizedTime;

	//	Try to initialize MemorizedITHL from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  memorizedITHL;
	else {
		//	Try to initialize MemorizedITHL from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  memorizedITHL;
	}
	//	And try to extract MemorizedITHL value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  memorizedITHL;

	//	Try to initialize MemorizedNbStackingImages from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  memorizedNbStackingImages;
	else {
		//	Try to initialize MemorizedNbStackingImages from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  memorizedNbStackingImages;
	}
	//	And try to extract MemorizedNbStackingImages value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  memorizedNbStackingImages;

	//	Try to initialize ModuleMask from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  moduleMask;
	else {
		//	Try to initialize ModuleMask from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  moduleMask;
	}
	//	And try to extract ModuleMask value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  moduleMask;



    //	End of Automatic code generation
    //------------------------------------------------------------------
    PropertyHelper::create_property_if_empty(this, dev_prop, "TO_BE_DEFINED", "HostName");
    PropertyHelper::create_property_if_empty(this, dev_prop, "TO_BE_DEFINED", "Port");
    PropertyHelper::create_property_if_empty(this, dev_prop, "TO_BE_DEFINED", "CalibrationPath");
    PropertyHelper::create_property_if_empty(this, dev_prop, "STANDARD", "MemorizedAcquisitionModMode");
    PropertyHelper::create_property_if_empty(this, dev_prop, "EXPOSURE_BUSY", "MemorizedOutputSignal");
    PropertyHelper::create_property_if_empty(this, dev_prop, "OTN_PULSE", "MemorizedCalibrationMode");    
	PropertyHelper::create_property_if_empty(this, dev_prop, "SLOW", "MemorizedMode");
	PropertyHelper::create_property_if_empty(this, dev_prop, "0", "MemorizedTime");
	PropertyHelper::create_property_if_empty(this, dev_prop, "0", "MemorizedITHL");	
	PropertyHelper::create_property_if_empty(this, dev_prop, "1", "MemorizedNbStackingImages");
    PropertyHelper::create_property_if_empty(this, dev_prop, "False", "MemorizedGeometricalCorrectionFlag");
    PropertyHelper::create_property_if_empty(this, dev_prop, "False", "MemorizedFlatFieldCorrectionFlag");
	PropertyHelper::create_property_if_empty(this, dev_prop, "0", "ModuleMask");
}
//+----------------------------------------------------------------------------
//
// method : 		ImXpad::always_executed_hook()
// 
// description : 	method always executed before any command is executed
//
//-----------------------------------------------------------------------------
void ImXpad::always_executed_hook()
{
    try
    {
        yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());
        m_status_message.str("");
        //- get the singleton control objet used to pilot the lima framework
        m_ct = ControlFactory::instance().get_control("ImXpad");

        //- get interface to specific camera
        m_hw = dynamic_cast<imXpad::Interface*> (m_ct->hwInterface());

        //- get camera to specific detector
        m_camera = &(m_hw->getCamera());

        //update state
        dev_state();
    }
    catch (Exception& e)
    {
        ERROR_STREAM << e.getErrMsg() << endl;
        m_status_message << "Initialization Failed : " << e.getErrMsg() << endl;
        //- throw exception
        set_state(Tango::FAULT);
        m_is_device_initialized = false;
        return;
    }
    catch (...)
    {
        ERROR_STREAM << "Initialization Failed : UNKNOWN" << endl;
        m_status_message << "Initialization Failed : UNKNOWN" << endl;
        //- throw exception
        set_state(Tango::FAULT);
        m_is_device_initialized = false;
        return;
    }
}
//+----------------------------------------------------------------------------
//
// method : 		ImXpad::read_attr_hardware
// 
// description : 	Hardware acquisition for attributes.
//
//-----------------------------------------------------------------------------
void ImXpad::read_attr_hardware(vector<long> &attr_list)
{
    DEBUG_STREAM << "ImXpad::read_attr_hardware(vector<long> &attr_list) entering... " << endl;
    //	Add your own code here
}
//+----------------------------------------------------------------------------
//
// method : 		ImXpad::read_calibrationExposureTime
// 
// description : 	Extract real attribute values for calibrationExposureTime acquisition result.
//
//-----------------------------------------------------------------------------
void ImXpad::read_calibrationExposureTime(Tango::Attribute &attr)
{
	DEBUG_STREAM << "ImXpad::read_calibrationExposureTime(Tango::Attribute &attr) entering... "<< endl;
}

//+----------------------------------------------------------------------------
//
// method : 		ImXpad::write_calibrationExposureTime
// 
// description : 	Write calibrationExposureTime attribute values to hardware.
//
//-----------------------------------------------------------------------------
void ImXpad::write_calibrationExposureTime(Tango::WAttribute &attr)
{
	INFO_STREAM << "ImXpad::write_calibrationExposureTime(Tango::WAttribute &attr) entering... "<< endl;
    
    try
    {
        attr.get_write_value(attr_calibrationExposureTime_write);
        yat4tango::PropertyHelper::set_property(this, "MemorizedTime", attr_calibrationExposureTime_write);//TODO SBA
    }
    catch(Tango::DevFailed& df)
    {
        ERROR_STREAM << df << endl;
        //- rethrow exception
        Tango::Except::re_throw_exception(df,
                                          "TANGO_DEVICE_ERROR",
                                          std::string(df.errors[0].desc).c_str(),
                                          "ImXpad::write_calibrationExposureTime");
    }
    
}

//+----------------------------------------------------------------------------
//
// method : 		ImXpad::read_CalibrationBeamITHL
// 
// description : 	Extract real attribute values for CalibrationBeamITHL acquisition result.
//
//-----------------------------------------------------------------------------
void ImXpad::read_CalibrationBeamITHL(Tango::Attribute &attr)
{
	DEBUG_STREAM << "ImXpad::read_CalibrationBeamITHL(Tango::Attribute &attr) entering... "<< endl;
}

//+----------------------------------------------------------------------------
//
// method : 		ImXpad::write_CalibrationBeamITHL
// 
// description : 	Write CalibrationBeamITHL attribute values to hardware.
//
//-----------------------------------------------------------------------------
void ImXpad::write_CalibrationBeamITHL(Tango::WAttribute &attr)
{
	INFO_STREAM << "ImXpad::write_CalibrationBeamITHL(Tango::WAttribute &attr) entering... "<< endl;
    
    try
    {
        attr.get_write_value(attr_CalibrationBeamITHL_write);
        yat4tango::PropertyHelper::set_property(this, "MemorizedITHL", attr_CalibrationBeamITHL_write);//TODO SBA
    }
    catch(Tango::DevFailed& df)
    {
        ERROR_STREAM << df << endl;
        //- rethrow exception
        Tango::Except::re_throw_exception(df,
                                          "TANGO_DEVICE_ERROR",
                                          std::string(df.errors[0].desc).c_str(),
                                          "ImXpad::write_CalibrationBeamITHL");
    }
}

//+----------------------------------------------------------------------------
//
// method : 		ImXpad::read_calibrationConfigMode
// 
// description : 	Extract real attribute values for calibrationConfigMode acquisition result.
//
//-----------------------------------------------------------------------------
void ImXpad::read_calibrationConfigMode(Tango::Attribute &attr)
{
	DEBUG_STREAM << "ImXpad::read_calibrationConfigMode(Tango::Attribute &attr) entering... "<< endl;
}

//+----------------------------------------------------------------------------
//
// method : 		ImXpad::write_calibrationConfigMode
// 
// description : 	Write calibrationConfigMode attribute values to hardware.
//
//-----------------------------------------------------------------------------
void ImXpad::write_calibrationConfigMode(Tango::WAttribute &attr)
{
	INFO_STREAM << "ImXpad::write_calibrationConfigMode(Tango::WAttribute &attr) entering... "<< endl;

	try
	{
		m_mode = attr_calibrationConfigMode_write;
		attr.get_write_value(attr_calibrationConfigMode_write);
		string current = attr_calibrationConfigMode_write;
		transform(current.begin(), current.end(), current.begin(), ::toupper);
        if (current != "SLOW" &&
            current != "MEDIUM" &&
            current != "FAST")
        {
			attr_calibrationConfigMode_write = const_cast<Tango::DevString>(m_mode.c_str());
			string userMsg;
            userMsg = 	string("Available Mode are:\n- ") +   
			string("SLOW") + string("\n- ") + 
			string("MEDIUM")+ string("\n- ") + 
			string("FAST") + string("\n"); 

            Tango::Except::throw_exception(	"CONFIGURATION_ERROR",
                                            userMsg.c_str(),
                                            "ImXpad::write_calibrationConfigMode");
		}

		//- THIS IS AN AVAILABLE CONFIGURATION MODE
		m_mode = current;
		attr_calibrationConfigMode_write = const_cast<Tango::DevString>(current.c_str());
		//memorize it ...
		PropertyHelper::set_property(this, "MemorizedMode", m_mode);
	}
	catch(Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		Tango::Except::re_throw_exception(df,
                                          "TANGO_DEVICE_ERROR",
                                          string(df.errors[0].desc).c_str(),
                                          "ImXpad::write_calibrationConfigMode");
	}
}

//+----------------------------------------------------------------------------
//
// method : 		ImXpad::read_calibrationPath
// 
// description : 	Extract real attribute values for calibrationPath acquisition result.
//
//-----------------------------------------------------------------------------
void ImXpad::read_calibrationPath(Tango::Attribute &attr)
{
	DEBUG_STREAM << "ImXpad::read_calibrationPath(Tango::Attribute &attr) entering... "<< endl;
    try
    {
        attr.set_value(attr_calibrationPath_read);
    }
    catch (Tango::DevFailed& df)
    {
        ERROR_STREAM << df << endl;
        //- rethrow exception
        Tango::Except::re_throw_exception(df,
                                          "TANGO_DEVICE_ERROR",
                                          string(df.errors[0].desc).c_str(),
                                          "ImXpad::read_calibrationPath");
    }
    catch (Exception& e)
    {
        ERROR_STREAM << e.getErrMsg() << endl;
        //- throw exception
        Tango::Except::throw_exception("TANGO_DEVICE_ERROR",
                                       e.getErrMsg().c_str(),
                                       "ImXpad::read_calibrationPath");
    }
}


//+----------------------------------------------------------------------------
//
// method : 		ImXpad::read_calibrationFileName
// 
// description : 	Extract real attribute values for calibrationFileName acquisition result.
//
//-----------------------------------------------------------------------------
void ImXpad::read_calibrationFileName(Tango::Attribute &attr)
{
	DEBUG_STREAM << "ImXpad::read_calibrationFileName(Tango::Attribute &attr) entering... "<< endl;
    try
    {
        attr.set_value(attr_calibrationFileName_read);
    }
    catch (Tango::DevFailed& df)
    {
        ERROR_STREAM << df << endl;
        //- rethrow exception
        Tango::Except::re_throw_exception(df,
                                          "TANGO_DEVICE_ERROR",
                                          string(df.errors[0].desc).c_str(),
                                          "ImXpad::read_calibrationFileName");
    }
    catch (Exception& e)
    {
        ERROR_STREAM << e.getErrMsg() << endl;
        //- throw exception
        Tango::Except::throw_exception("TANGO_DEVICE_ERROR",
                                       e.getErrMsg().c_str(),
                                       "ImXpad::read_calibrationFileName");
    }
}


//+----------------------------------------------------------------------------
//
// method : 		ImXpad::read_geometricalCorrectionFlag
// 
// description : 	Extract real attribute values for geometricalCorrectionFlag acquisition result.
//
//-----------------------------------------------------------------------------
void ImXpad::read_geometricalCorrectionFlag(Tango::Attribute &attr)
{
	DEBUG_STREAM << "ImXpad::read_geometricalCorrectionFlag(Tango::Attribute &attr) entering... "<< endl;
    yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());
    try
    {
        *attr_geometricalCorrectionFlag_read = static_cast<Tango::DevBoolean>(m_camera->getGeometricalCorrectionFlag());
        attr.set_value(attr_geometricalCorrectionFlag_read);
    }
    catch(Tango::DevFailed& df)
    {
        ERROR_STREAM << df << endl;
        //- rethrow exception
        Tango::Except::re_throw_exception(df,
                                          "TANGO_DEVICE_ERROR",
                                          std::string(df.errors[0].desc).c_str(),
                                          "ImXpad::read_geometricalCorrectionFlag");
    }
    catch(Exception& e)
    {
        ERROR_STREAM << e.getErrMsg() << endl;
        m_status_message.str("");
        m_status_message << e.getErrMsg().c_str() << endl;
        //- throw exception
        Tango::Except::throw_exception("TANGO_DEVICE_ERROR",
                                       e.getErrMsg().c_str(),
                                       "ImXpad::read_geometricalCorrectionFlag");
    }
}

//+----------------------------------------------------------------------------
//
// method : 		ImXpad::write_geometricalCorrectionFlag
// 
// description : 	Write geometricalCorrectionFlag attribute values to hardware.
//
//-----------------------------------------------------------------------------
void ImXpad::write_geometricalCorrectionFlag(Tango::WAttribute &attr)
{
	INFO_STREAM << "ImXpad::write_geometricalCorrectionFlag(Tango::WAttribute &attr) entering... "<< endl;
    yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());
    try
    {
        attr.get_write_value(attr_geometricalCorrectionFlag_write);
        m_camera->setGeometricalCorrectionFlag(static_cast<unsigned short>(attr_geometricalCorrectionFlag_write));
        yat4tango::PropertyHelper::set_property(this, "MemorizedGeometricalCorrectionFlag", attr_geometricalCorrectionFlag_write);
    }
    catch(Tango::DevFailed& df)
    {
        ERROR_STREAM << df << endl;
        //- rethrow exception
        Tango::Except::re_throw_exception(df,
                                          "TANGO_DEVICE_ERROR",
                                          std::string(df.errors[0].desc).c_str(),
                                          "ImXpad::write_geometricalCorrectionFlag");
    }
    catch(Exception& e)
    {
        ERROR_STREAM << e.getErrMsg() << endl;
        m_status_message.str("");
        m_status_message << e.getErrMsg().c_str() << endl;
        //- throw exception
        Tango::Except::throw_exception("TANGO_DEVICE_ERROR",
                                       e.getErrMsg().c_str(),
                                       "ImXpad::write_geometricalCorrectionFlag");
    }
}

//+----------------------------------------------------------------------------
//
// method : 		ImXpad::read_flatFieldCorrectionFlag
// 
// description : 	Extract real attribute values for flatFieldCorrectionFlag acquisition result.
//
//-----------------------------------------------------------------------------
void ImXpad::read_flatFieldCorrectionFlag(Tango::Attribute &attr)
{
	DEBUG_STREAM << "ImXpad::read_flatFieldCorrectionFlag(Tango::Attribute &attr) entering... "<< endl;
    yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());
    try
    {
        *attr_flatFieldCorrectionFlag_read = static_cast<Tango::DevBoolean>(m_camera->getFlatFieldCorrectionFlag());
        attr.set_value(attr_flatFieldCorrectionFlag_read);
    }
    catch(Tango::DevFailed& df)
    {
        ERROR_STREAM << df << endl;
        //- rethrow exception
        Tango::Except::re_throw_exception(df,
                                          "TANGO_DEVICE_ERROR",
                                          std::string(df.errors[0].desc).c_str(),
                                          "ImXpad::read_flatFieldCorrectionFlag");
    }
    catch(Exception& e)
    {
        ERROR_STREAM << e.getErrMsg() << endl;
        m_status_message.str("");
        m_status_message << e.getErrMsg().c_str() << endl;
        //- throw exception
        Tango::Except::throw_exception("TANGO_DEVICE_ERROR",
                                       e.getErrMsg().c_str(),
                                       "ImXpad::read_flatFieldCorrectionFlag");
    }
}

//+----------------------------------------------------------------------------
//
// method : 		ImXpad::write_flatFieldCorrectionFlag
// 
// description : 	Write flatFieldCorrectionFlag attribute values to hardware.
//
//-----------------------------------------------------------------------------
void ImXpad::write_flatFieldCorrectionFlag(Tango::WAttribute &attr)
{
	INFO_STREAM << "ImXpad::write_flatFieldCorrectionFlag(Tango::WAttribute &attr) entering... "<< endl;
    yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());
    try
    {
        attr.get_write_value(attr_flatFieldCorrectionFlag_write);
        m_camera->setFlatFieldCorrectionFlag(static_cast<unsigned short>(attr_flatFieldCorrectionFlag_write));
        yat4tango::PropertyHelper::set_property(this, "MemorizedFlatFieldCorrectionFlag", attr_flatFieldCorrectionFlag_write);
    }
    catch(Tango::DevFailed& df)
    {
        ERROR_STREAM << df << endl;
        //- rethrow exception
        Tango::Except::re_throw_exception(df,
                                          "TANGO_DEVICE_ERROR",
                                          std::string(df.errors[0].desc).c_str(),
                                          "ImXpad::write_flatFieldCorrectionFlag");
    }
    catch(Exception& e)
    {
        ERROR_STREAM << e.getErrMsg() << endl;
        m_status_message.str("");
        m_status_message << e.getErrMsg().c_str() << endl;
        //- throw exception
        Tango::Except::throw_exception("TANGO_DEVICE_ERROR",
                                       e.getErrMsg().c_str(),
                                       "ImXpad::write_flatFieldCorrectionFlag");
    }
}


//+----------------------------------------------------------------------------
//
// method : 		ImXpad::read_serverVersion
// 
// description : 	Extract real attribute values for serverVersion acquisition result.
//
//-----------------------------------------------------------------------------
void ImXpad::read_serverVersion(Tango::Attribute &attr)
{
	DEBUG_STREAM << "ImXpad::read_serverVersion(Tango::Attribute &attr) entering... "<< endl;
    try
    {
        strcpy(*attr_serverVersion_read, SOCKET_SERVER_VERSION);

        attr.set_value(attr_serverVersion_read);
    }
    catch (Tango::DevFailed& df)
    {
        ERROR_STREAM << df << endl;
        //- rethrow exception
        Tango::Except::re_throw_exception(df,
                                          "TANGO_DEVICE_ERROR",
                                          string(df.errors[0].desc).c_str(),
                                          "ImXpad::read_serverVersion");
    }
    catch (Exception& e)
    {
        ERROR_STREAM << e.getErrMsg() << endl;
        //- throw exception
        Tango::Except::throw_exception("TANGO_DEVICE_ERROR",
                                       e.getErrMsg().c_str(),
                                       "ImXpad::read_serverVersion");
    }
}

//+----------------------------------------------------------------------------
//
// method : 		ImXpad::read_acquisitionMode
// 
// description : 	Extract real attribute values for acquisitionMode acquisition result.
//
//-----------------------------------------------------------------------------
void ImXpad::read_acquisitionMode(Tango::Attribute &attr)
{
	DEBUG_STREAM << "ImXpad::read_acquisitionMode(Tango::Attribute &attr) entering... "<< endl;
    try
    {

        unsigned int mode_enum = m_camera->getAcquisitionMode();
        std::string acquisition_mode = "";
        switch(mode_enum)
        {
            case imXpad::Camera::XpadAcquisitionMode::Standard:
                acquisition_mode = "STANDARD";
                break;
            case imXpad::Camera::XpadAcquisitionMode::ComputerBurst:
                acquisition_mode = "COMPUTER_BURST";
                break;
            case imXpad::Camera::XpadAcquisitionMode::DetectorBurst:
                acquisition_mode = "DETECTOR_BURST";
                break;
            case imXpad::Camera::XpadAcquisitionMode::Stacking16bits:
                acquisition_mode = "STACKING_16";
                break;
            case imXpad::Camera::XpadAcquisitionMode::Stacking32bits:
                acquisition_mode = "STACKING_32";
                break;
            case imXpad::Camera::XpadAcquisitionMode::SingleBunch16bits:
                acquisition_mode = "SINGLE_BUNCH_16";
                break;
            case imXpad::Camera::XpadAcquisitionMode::SingleBunch32bits:
                acquisition_mode = "SINGLE_BUNCH_32";
                break;				
            default:
                acquisition_mode = "UNKNOWN ACQUISITION MODE !";
                break;
        }

        strcpy(*attr_acquisitionMode_read, acquisition_mode.c_str());
        attr.set_value(attr_acquisitionMode_read);
    }
    catch(Tango::DevFailed& df)
    {
        ERROR_STREAM << df << endl;
        //- rethrow exception
        Tango::Except::re_throw_exception(df,
                                          "TANGO_DEVICE_ERROR",
                                          std::string(df.errors[0].desc).c_str(),
                                          "ImXpad::read_acquisitionMode");
    }
    catch(Exception& e)
    {
        ERROR_STREAM << e.getErrMsg() << endl;
        //- throw exception
        Tango::Except::throw_exception("TANGO_DEVICE_ERROR",
                                       e.getErrMsg().c_str(),
                                       "ImXpad::read_acquisitionMode");
    }
}

//+----------------------------------------------------------------------------
//
// method : 		ImXpad::write_acquisitionMode
// 
// description : 	Write acquisitionMode attribute values to hardware.
//
//-----------------------------------------------------------------------------
void ImXpad::write_acquisitionMode(Tango::WAttribute &attr)
{
	INFO_STREAM << "ImXpad::write_acquisitionMode(Tango::WAttribute &attr) entering... "<< endl;
    try
    {
        m_acquisition_mode = attr_acquisitionMode_write;
        attr.get_write_value(attr_acquisitionMode_write);
        string current = attr_acquisitionMode_write;
        transform(current.begin(), current.end(), current.begin(), ::toupper);
        if (current != "STANDARD" &&
            current != "COMPUTER_BURST" &&
			current != "DETECTOR_BURST" &&
			current != "STACKING_16" &&
			current != "STACKING_32" &&
			current != "SINGLE_BUNCH_16" &&
			current != "SINGLE_BUNCH_32")
        {            
            attr_acquisitionMode_write = const_cast<Tango::DevString>(m_acquisition_mode.c_str());
            string userMsg;
            userMsg = 	string("Available acquisitionMode are:\n- ") +
            string("STANDARD") + string("\n- ") +
            string("COMPUTER_BURST")+ string("\n- ") +
            string("DETECTOR_BURST") + string("\n- ")+
			string("STACKING_16") + string("\n- ")+
			string("STACKING_32") + string("\n- ")+
			string("SINGLE_BUNCH_16") + string("\n- ")+
			string("SINGLE_BUNCH_32") + string("\n");

            Tango::Except::throw_exception(	"CONFIGURATION_ERROR",
                                            userMsg.c_str(),
                                            "ImXpad::write_acquisitionMode");
        }


        //- THIS IS AN AVAILABLE ACQUISITION MODE
        m_acquisition_mode = current;
        attr_acquisitionMode_write = const_cast<Tango::DevString>(current.c_str());
        //send it to the imxpad
        if(m_acquisition_mode == "STANDARD")
            m_acquisition_mode_enum = imXpad::Camera::XpadAcquisitionMode::Standard;
        else if(m_acquisition_mode == "COMPUTER_BURST")
            m_acquisition_mode_enum = imXpad::Camera::XpadAcquisitionMode::ComputerBurst;
        else if(m_acquisition_mode == "DETECTOR_BURST")
            m_acquisition_mode_enum = imXpad::Camera::XpadAcquisitionMode::DetectorBurst;		
        else if(m_acquisition_mode == "STACKING_16")
            m_acquisition_mode_enum = imXpad::Camera::XpadAcquisitionMode::Stacking16bits;
        else if(m_acquisition_mode == "STACKING_32")
            m_acquisition_mode_enum = imXpad::Camera::XpadAcquisitionMode::Stacking32bits;		
        else if(m_acquisition_mode == "SINGLE_BUNCH_16")
            m_acquisition_mode_enum = imXpad::Camera::XpadAcquisitionMode::SingleBunch16bits;
        else //if(m_acquisition_mode == "SINGLE_BUNCH_32")
            m_acquisition_mode_enum = imXpad::Camera::XpadAcquisitionMode::SingleBunch32bits;				


        m_camera->setAcquisitionMode(m_acquisition_mode_enum);
        //memorize it ...
        PropertyHelper::set_property(this, "MemorizedAcquisitionMode", m_acquisition_mode);
    }
    catch(Tango::DevFailed& df)
    {
        ERROR_STREAM << df << endl;
        //- rethrow exception
        Tango::Except::re_throw_exception(df,
                                          "TANGO_DEVICE_ERROR",
                                          string(df.errors[0].desc).c_str(),
                                          "ImXpad::write_acquisitionMode");
    }
}

//+----------------------------------------------------------------------------
//
// method : 		ImXpad::read_nbStackingImages
// 
// description : 	Extract real attribute values for nbStackingImages acquisition result.
//
//-----------------------------------------------------------------------------
void ImXpad::read_nbStackingImages(Tango::Attribute &attr)
{
	DEBUG_STREAM << "ImXpad::read_nbStackingImages(Tango::Attribute &attr) entering... "<< endl;
}

//+----------------------------------------------------------------------------
//
// method : 		ImXpad::write_nbStackingImages
// 
// description : 	Write nbStackingImages attribute values to hardware.
//
//-----------------------------------------------------------------------------
void ImXpad::write_nbStackingImages(Tango::WAttribute &attr)
{
	INFO_STREAM << "ImXpad::write_nbStackingImages(Tango::WAttribute &attr) entering... "<< endl;
    try
    {
        attr.get_write_value(attr_nbStackingImages_write);
		m_camera->setStackImages(attr_nbStackingImages_write);
		//memorize it ...
        yat4tango::PropertyHelper::set_property(this, "MemorizedNbStackingImages", attr_nbStackingImages_write);
    }
    catch(Tango::DevFailed& df)
    {
        ERROR_STREAM << df << endl;
        //- rethrow exception
        Tango::Except::re_throw_exception(df,
                                          "TANGO_DEVICE_ERROR",
                                          std::string(df.errors[0].desc).c_str(),
                                          "ImXpad::write_nbStackingImages");
    }
}

//+----------------------------------------------------------------------------
//
// method : 		ImXpad::read_outputSignal
// 
// description : 	Extract real attribute values for outputSignal acquisition result.
//
//-----------------------------------------------------------------------------
void ImXpad::read_outputSignal(Tango::Attribute &attr)
{
	DEBUG_STREAM << "ImXpad::read_outputSignal(Tango::Attribute &attr) entering... "<< endl;
    try
    {


        unsigned short signal_enum = -1;
        m_camera->getOutputSignalMode(signal_enum);
        std::string output_signal = "";
        switch(signal_enum)
        {
            case imXpad::Camera::XpadOutputSignal::ExposureBusy:
                output_signal = "EXPOSURE_BUSY";
                break;
            case imXpad::Camera::XpadOutputSignal::ShutterBusy:
                output_signal = "SHUTTER_BUSY";
                break;
            case imXpad::Camera::XpadOutputSignal::BusyUpdateOverflow:
                output_signal = "BUSY_UPDATE_OVER_FLOW";
                break;
            case imXpad::Camera::XpadOutputSignal::PixelCounterEnabled:
                output_signal = "PIXEL_COUNTER_ENABLED";
                break;
            case imXpad::Camera::XpadOutputSignal::ExternalGate:
                output_signal = "EXTERNAL_GATE";
                break;
            case imXpad::Camera::XpadOutputSignal::ExposureReadDone:
                output_signal = "EXPOSURE_READ_DONE";
                break;
            case imXpad::Camera::XpadOutputSignal::DataTransfer:
                output_signal = "DATA_TRANSFER";
                break;
            case imXpad::Camera::XpadOutputSignal::RAMReadyImageBusy:
                output_signal = "RAM_READ_IMAGE_BUSY";
                break;
            case imXpad::Camera::XpadOutputSignal::XPADToLocalDDR:
                output_signal = "XPAD_TO_LOCAL_DDR";
                break;
            case imXpad::Camera::XpadOutputSignal::LocalDDRToPC:
                output_signal = "LOCAL_DDR_TO_PC";
                break;

            default:
                output_signal = "UNKNOWN OUTPUT SIGNAL !";
                break;
        }

        strcpy(*attr_outputSignal_read, output_signal.c_str());
        attr.set_value(attr_outputSignal_read);
    }
    catch(Tango::DevFailed& df)
    {
        ERROR_STREAM << df << endl;
        //- rethrow exception
        Tango::Except::re_throw_exception(df,
                                          "TANGO_DEVICE_ERROR",
                                          std::string(df.errors[0].desc).c_str(),
                                          "ImXpad::read_outputSignal");
    }
    catch(Exception& e)
    {
        ERROR_STREAM << e.getErrMsg() << endl;
        //- throw exception
        Tango::Except::throw_exception("TANGO_DEVICE_ERROR",
                                       e.getErrMsg().c_str(),
                                       "ImXpad::read_outputSignal");
    }
}

//+----------------------------------------------------------------------------
//
// method : 		ImXpad::write_outputSignal
// 
// description : 	Write outputSignal attribute values to hardware.
//
//-----------------------------------------------------------------------------
void ImXpad::write_outputSignal(Tango::WAttribute &attr)
{
	INFO_STREAM << "ImXpad::write_outputSignal(Tango::WAttribute &attr) entering... "<< endl;
    try
    {
        m_output_signal = attr_outputSignal_write;
        attr.get_write_value(attr_outputSignal_write);
        string current = attr_outputSignal_write;
        transform(current.begin(), current.end(), current.begin(), ::toupper);
        if (current != "EXPOSURE_BUSY"          &&
            current != "SHUTTER_BUSY"           &&
            current != "BUSY_UPDATE_OVER_FLOW"  &&
            current != "PIXEL_COUNTER_ENABLED"  &&
            current != "EXTERNAL_GATE"          &&
            current != "EXPOSURE_READ_DONE"     &&
            current != "DATA_TRANSFER"          &&
            current != "RAM_READ_IMAGE_BUSY"    &&
            current != "XPAD_TO_LOCAL_DDR"      &&
            current != "LOCAL_DDR_TO_PC"
            )
        {
            attr_outputSignal_write = const_cast<Tango::DevString>(m_output_signal.c_str());
            string userMsg;
            userMsg = 	string("Available outputSignal are:\n- ") +
            string("EXPOSURE_BUSY")         + string("\n- ") +
            string("SHUTTER_BUSY")          + string("\n- ") +
            string("BUSY_UPDATE_OVER_FLOW") + string("\n- ") +
            string("PIXEL_COUNTER_ENABLED") + string("\n- ") +
            string("EXTERNAL_GATE")         + string("\n- ") +
            string("EXPOSURE_READ_DONE")    + string("\n- ") +
            string("DATA_TRANSFER")         + string("\n- ") +
            string("RAM_READ_IMAGE_BUSY")   + string("\n- ") +
            string("XPAD_TO_LOCAL_DDR")     + string("\n- ") +
            string("LOCAL_DDR_TO_PC")       + string("\n");

            Tango::Except::throw_exception(	"CONFIGURATION_ERROR",
                                            userMsg.c_str(),
                                            "ImXpad::write_outputSignal");
        }

        //- THIS IS AN AVAILABLE ACQUISITION MODE
        m_output_signal = current;
        attr_outputSignal_write = const_cast<Tango::DevString>(current.c_str());
        //send it to the imxpad
        if(m_output_signal == "EXPOSURE_BUSY")
            m_output_signal_enum = imXpad::Camera::XpadOutputSignal::ExposureBusy;
        else if(m_output_signal == "SHUTTER_BUSY")
            m_output_signal_enum = imXpad::Camera::XpadOutputSignal::ShutterBusy;
        else if(m_output_signal == "BUSY_UPDATE_OVER_FLOW")
            m_output_signal_enum = imXpad::Camera::XpadOutputSignal::BusyUpdateOverflow;
        else if(m_output_signal == "PIXEL_COUNTER_ENABLED")
            m_output_signal_enum = imXpad::Camera::XpadOutputSignal::PixelCounterEnabled;
        else if(m_output_signal == "EXTERNAL_GATE")
            m_output_signal_enum = imXpad::Camera::XpadOutputSignal::ExternalGate;
        else if(m_output_signal == "EXPOSURE_READ_DONE")
            m_output_signal_enum = imXpad::Camera::XpadOutputSignal::ExposureReadDone;
        else if(m_output_signal == "DATA_TRANSFER")
            m_output_signal_enum = imXpad::Camera::XpadOutputSignal::DataTransfer;
        else if(m_output_signal == "RAM_READ_IMAGE_BUSY")
            m_output_signal_enum = imXpad::Camera::XpadOutputSignal::RAMReadyImageBusy;
        else if(m_output_signal == "XPAD_TO_LOCAL_DDR")
            m_output_signal_enum = imXpad::Camera::XpadOutputSignal::XPADToLocalDDR;
        else //if(m_output_signal == "LOCAL_DDR_TO_PC")
            m_output_signal_enum = imXpad::Camera::XpadOutputSignal::LocalDDRToPC;

        m_camera->setOutputSignalMode(m_output_signal_enum);
        //memorize it ...
        PropertyHelper::set_property(this, "MemorizedOutputSignal", m_output_signal);
    }
    catch(Tango::DevFailed& df)
    {
        ERROR_STREAM << df << endl;
        //- rethrow exception
        Tango::Except::re_throw_exception(df,
                                          "TANGO_DEVICE_ERROR",
                                          string(df.errors[0].desc).c_str(),
                                          "ImXpad::write_outputSignal");
    }
}

//+----------------------------------------------------------------------------
//
// method : 		ImXpad::read_calibrationMode
// 
// description : 	Extract real attribute values for calibrationMode acquisition result.
//
//-----------------------------------------------------------------------------
void ImXpad::read_calibrationMode(Tango::Attribute &attr)
{
	DEBUG_STREAM << "ImXpad::read_calibrationMode(Tango::Attribute &attr) entering... "<< endl;
}

//+----------------------------------------------------------------------------
//
// method : 		ImXpad::write_calibrationMode
// 
// description : 	Write calibrationMode attribute values to hardware.
//
//-----------------------------------------------------------------------------
void ImXpad::write_calibrationMode(Tango::WAttribute &attr)
{
	INFO_STREAM << "ImXpad::write_calibrationMode(Tango::WAttribute &attr) entering... "<< endl;
	try
	{
		m_calibration_mode = attr_calibrationMode_write;
		attr.get_write_value(attr_calibrationMode_write);
		string current = attr_calibrationMode_write;
		transform(current.begin(), current.end(), current.begin(), ::toupper);
        if (current != "OTN_PULSE" &&
            current != "OTN" &&
            current != "BEAM")
		{			
			attr_calibrationMode_write = const_cast<Tango::DevString>(m_calibration_mode.c_str());
			string userMsg;
            userMsg = 	string("Available calibrationMode are:\n- ") +   
			string("OTN_PULSE") + string("\n- ") + 
			string("OTN")+ string("\n- ") + 
			string("BEAM") + string("\n"); 

            Tango::Except::throw_exception(	"CONFIGURATION_ERROR",
                                            userMsg.c_str(),
                                            "ImXpad::write_calibrationMode");
		}

		
		//- THIS IS AN AVAILABLE CALIBRATION MODE
		m_calibration_mode = current;
		attr_calibrationMode_write = const_cast<Tango::DevString>(current.c_str());
		PropertyHelper::set_property(this, "MemorizedCalibrationMode", m_calibration_mode);
	}
	catch(Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		Tango::Except::re_throw_exception(df,
                                          "TANGO_DEVICE_ERROR",
                                          string(df.errors[0].desc).c_str(),
                                          "ImXpad::write_calibrationMode");
	}
}


//+------------------------------------------------------------------
/**
 *    method:    ImXpad::dev_state
 *
 *    description:    method to execute "State"
 *    This command gets the device state (stored in its <i>device_state</i> data member) and returns it to the caller.
 *
 * @return    State Code
 *
 */
//+------------------------------------------------------------------
Tango::DevState ImXpad::dev_state()
{
    Tango::DevState argout = DeviceImpl::dev_state();
    DEBUG_STREAM << "ImXpad::dev_state(): entering... !" << endl;

    //    Add your own code to control device here
    stringstream DeviceStatus;
    DeviceStatus << "";
    Tango::DevState DeviceState = Tango::STANDBY;
    if (!m_is_device_initialized)
    {
        DeviceState = Tango::FAULT;
        DeviceStatus << m_status_message.str();
    }
    else
    {
        // state & status are retrieved from Factory, Factory is updated by Generic device
        DeviceState = ControlFactory::instance().get_state();
        DeviceStatus << ControlFactory::instance().get_status();
    }

    set_state(DeviceState);
    set_status(DeviceStatus.str());

    argout = DeviceState;
    return argout;
}


//+------------------------------------------------------------------
/**
 *	method:	ImXpad::start_calibration
 *
 *	description:	method to execute "StartCalibration"
 *	Start the calibration of detector <br>
 *
 *
 */
//+------------------------------------------------------------------
void ImXpad::start_calibration()
{
    INFO_STREAM << "ImXpad::start_calibration(): entering... !" << endl;

    //	Add your own code to control device here
    yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());
    try
    {
        //define the mode enum, usefull in start_calibration....
        imXpad::Camera::Calibration::Configuration mode_enum;
        if(m_mode == "SLOW")
            mode_enum = imXpad::Camera::Calibration::Slow;
        if(m_mode == "MEDIUM")
            mode_enum = imXpad::Camera::Calibration::Medium;
        if(m_mode == "FAST")
            mode_enum = imXpad::Camera::Calibration::Fast;

        std::string calibration_mode = attr_calibrationMode_write;
        if(m_calibration_mode == "OTN_PULSE")
        {
            m_camera->calibrationOTNPulse(static_cast<unsigned short>(mode_enum));
        }
        else if(m_calibration_mode == "OTN")
        {
            m_camera->calibrationOTN(static_cast<unsigned short>(mode_enum));
        }
        else if(m_calibration_mode == "BEAM")
        {
            m_camera->calibrationBEAM(attr_calibrationExposureTime_write, attr_CalibrationBeamITHL_write ,static_cast<unsigned short>(mode_enum));
        }
        else
        {
            string userMsg;
            userMsg = 	string("Available calibrationMode are:\n- ") +
            string("OTN_PULSE") + string("\n- ") +
            string("OTN")+ string("\n- ") +
            string("BEAM")+ string("\n");

            Tango::Except::throw_exception(	"CONFIGURATION_ERROR",
                                            userMsg.c_str(),
                                            "ImXpad::start_calibration");
        }
    }
    catch (Exception& e)
    {
        ERROR_STREAM << e.getErrMsg() << endl;
        //- throw exception
        Tango::Except::throw_exception( "TANGO_DEVICE_ERROR",
                                        e.getErrMsg().c_str(),
                                        "ImXpad::start_calibration" );
    }
}

//+------------------------------------------------------------------
/**
 *	method:	ImXpad::create_white_image
 *
 *	description:	method to execute "CreateWhiteImage"
 *	Create the White image
 *
 * @param	argin	White image name
 *
 */
//+------------------------------------------------------------------
void ImXpad::create_white_image(Tango::DevString argin)
{
	INFO_STREAM << "ImXpad::create_white_image(): entering... !" << endl;
	//	Add your own code to control device here
    yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());
    try
    {
        m_camera->createWhiteImage(argin);
    }
    catch (Exception& e)
    {
        ERROR_STREAM << e.getErrMsg() << endl;
        //- throw exception
        Tango::Except::throw_exception( "TANGO_DEVICE_ERROR",
                                        e.getErrMsg().c_str(),
                                        "ImXpad::create_white_image" );
    }
}

//+------------------------------------------------------------------
/**
 *	method:	ImXpad::choose_white_image
 *
 *	description:	method to execute "ChooseWhiteImage"
 *	Select the white image
 *
 * @param	argin	White image name
 *
 */
//+------------------------------------------------------------------
void ImXpad::choose_white_image(Tango::DevString argin)
{
	INFO_STREAM << "ImXpad::choose_white_image(): entering... !" << endl;

	//	Add your own code to control device here
    yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());
    try
    {
        std::string  white_images = m_camera->getWhiteImagesInDir();
        std::vector<std::string> white_images_list;
        _split(white_images,", ",white_images_list);
        std::string  item = argin;
        if(std::find(white_images_list.begin(), white_images_list.end(), item) != white_images_list.end())
        {
            m_camera->setWhiteImage(argin);
        }
        else
        {
            std::stringstream ss;
            ss << "Unable to find the white image [" << argin << "]" << endl;
            Tango::Except::throw_exception(	"TANGO_DEVICE_ERROR",
                                           (ss.str()).c_str(),
                                           "ImXpad::choose_white_image");
        }
    }
    catch (Exception& e)
    {
        ERROR_STREAM << e.getErrMsg() << endl;
        //- throw exception
        Tango::Except::throw_exception("TANGO_DEVICE_ERROR",
                                       e.getErrMsg().c_str(),
                                       "ImXpad::choose_white_image" );
    }
}

//+------------------------------------------------------------------
/**
 *	method:	ImXpad::get_white_images_list
 *
 *	description:	method to execute "GetWhiteImagesList"
 *	Display the list of available White images
 *
 * @return	
 *
 */
//+------------------------------------------------------------------
Tango::DevVarStringArray *ImXpad::get_white_images_list()
{
	//	POGO has generated a method core with argout allocation.
	//	If you would like to use a static reference without copying,
	//	See "TANGO Device Server Programmer's Manual"
	//		(chapter : Writing a TANGO DS / Exchanging data)
	//------------------------------------------------------------
	Tango::DevVarStringArray	*argout  = new Tango::DevVarStringArray();
	INFO_STREAM << "ImXpad::get_white_images_list(): entering... !" << endl;

	//	Add your own code to control device here
    yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());
    try
    {
        std::string  white_images = m_camera->getWhiteImagesInDir();
        std::vector<std::string> white_images_list;
        _split(white_images,", ",white_images_list);
        argout->length(white_images_list.size());
        for(int i =0;i<white_images_list.size();i++)
        {
            INFO_STREAM<<"white image ["<<i<<"] = "<<white_images_list.at(i)<<std::endl;
            (*argout)[i] = CORBA::string_dup(white_images_list.at(i).c_str());
        }
    }
    catch (Tango::DevFailed& df)
    {
        ERROR_STREAM << df << endl;
        //- rethrow exception
        Tango::Except::re_throw_exception(df, "TANGO_DEVICE_ERROR",
                                          string(df.errors[0].desc).c_str(),
                                          "ImXpad::get_white_images_list" );
    }
    catch (Exception& e)
    {
        ERROR_STREAM << e.getErrMsg() << endl;
        //- throw exception
        Tango::Except::throw_exception("TANGO_DEVICE_ERROR",
                                       e.getErrMsg().c_str(),
                                       "ImXpad::get_white_images_list" );
    }
	return argout;
}



//+------------------------------------------------------------------
/**
 *	method:	ImXpad::delete_white_image
 *
 *	description:	method to execute "DeleteWhiteImage"
 *	Delete the white image
 *
 * @param	argin	White image name
 *
 */
//+------------------------------------------------------------------
void ImXpad::delete_white_image(Tango::DevString argin)
{
	INFO_STREAM << "ImXpad::delete_white_image(): entering... !" << endl;

	//	Add your own code to control device here
    yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());
    try
    {
        m_camera->deleteWhiteImage(argin);
    }
    catch (Exception& e)
    {
        ERROR_STREAM << e.getErrMsg() << endl;
        //- throw exception
        Tango::Except::throw_exception( "TANGO_DEVICE_ERROR",
                                        e.getErrMsg().c_str(),
                                        "ImXpad::delete_white_image" );
    }
}

//+------------------------------------------------------------------
/**
 *	method:	ImXpad::abort
 *
 *	description:	method to execute "Abort"
 *	Abort current process ...
 *
 *
 */
//+------------------------------------------------------------------
void ImXpad::abort()
{
	INFO_STREAM << "ImXpad::abort(): entering... !" << endl;

	//	Add your own code to control device here
    yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());
    try
    {
        m_camera->abortCurrentProcess();
    }
    catch (Exception& e)
    {
        ERROR_STREAM << e.getErrMsg() << endl;
        //- throw exception
        Tango::Except::throw_exception("TANGO_DEVICE_ERROR",
                                       e.getErrMsg().c_str(),
                                       "ImXpad::abort" );
    }

}


//+------------------------------------------------------------------
/**
 *	method:	ImXpad::save_calibration_file
 *
 *	description:	method to execute "SaveCalibrationFile"
 *	Save the calibration already done through the StartCalibartion in a file
 *
 * @param	argin	A target calibration file name
 *
 */
//+------------------------------------------------------------------
void ImXpad::save_calibration_file(Tango::DevString argin)
{
	INFO_STREAM << "ImXpad::save_calibration_file(): entering... !" << endl;

	//	Add your own code to control device here
    yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());
    try
    {
        std::string file_path_name = calibrationPath+"/"+argin;
        m_camera->saveCalibrationToFile(const_cast<char*>(file_path_name.c_str()));
    }
    catch (Exception& e)
    {
        ERROR_STREAM << e.getErrMsg() << endl;
        //- throw exception
        Tango::Except::throw_exception( "TANGO_DEVICE_ERROR",
                                        e.getErrMsg().c_str(),
                                        "ImXpad::save_calibration_file" );
    }

}

//+------------------------------------------------------------------
/**
 *	method:	ImXpad::load_calibration_file
 *
 *	description:	method to execute "LoadCalibrationFile"
 *	Load a calibration file<br>
 *
 * @param	argin	The calibration file Name 
 *
 */
//+------------------------------------------------------------------
void ImXpad::load_calibration_file(Tango::DevString argin)
{
	INFO_STREAM << "ImXpad::load_calibration_file(): entering... !" << endl;

	//	Add your own code to control device here
    yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());
    try
    {
        std::string file_path_name = calibrationPath+"/"+argin;
        std::string file_path_name_temp = file_path_name;

        //Verify if global calibration file is available
        size_t pos = file_path_name_temp.find(".cf");
        if (pos == std::string::npos)
        {
            file_path_name_temp = file_path_name_temp.append(".cfg");
            pos = file_path_name_temp.length() - 4;
        }

        yat::File file_cfg_path_name_file(file_path_name_temp);
        std::string file_cfg_data;
        file_cfg_path_name_file.load((std::string*) & file_cfg_data);

        //Verify if local calibration file is available
        std::string file_cfl_path_name = file_path_name_temp.replace(pos, 4, ".cfl");        
        yat::File file_cfl_path_name_file(file_cfl_path_name);
        std::string file_cfl_data;        
        file_cfl_path_name_file.load((std::string*) & file_cfl_data);

        if(file_cfg_data.size() > 0 && file_cfl_data.size() > 0)
        {
            m_camera->loadCalibrationFromFile(const_cast<char*>(file_path_name.c_str()));
            strcpy(*attr_calibrationFileName_read, argin);
        }
        else
        {
            if(!(file_cfg_data.size() > 0))
            {
                std::stringstream ss;
                ss << "The file " << file_path_name_temp << " is empty. " << std::endl;
                Tango::Except::throw_exception("TANGO_DEVICE_ERROR",
                        (ss.str()).c_str(),
                        "ImXpad::load_calibration_file");
            }
            else if(!(file_cfl_data.size() > 0))
            {
                std::stringstream ss;
                ss << "The file " << file_cfl_path_name << " is empty. " << std::endl;
                Tango::Except::throw_exception("TANGO_DEVICE_ERROR",
                        (ss.str()).c_str(),
                        "ImXpad::load_calibration_file");
            }
        }
    }
    catch(yat::Exception& ex)
    {
        THROW_YAT_TO_TANGO_EXCEPTION(ex);
    }
    catch (lima::Exception& e)
    {
        ERROR_STREAM << e.getErrMsg() << endl;
        //- throw exception
        Tango::Except::throw_exception( "TANGO_DEVICE_ERROR",
                    e.getErrMsg().c_str(),
                    "ImXpad::load_calibration_file");
    }
    catch(...)
    {
        ERROR_STREAM << "ImXpad::load_calibration_file() : Unknown Error" << endl;
    }
}


//+------------------------------------------------------------------
/**
 *	method:	ImXpad::ithlincrease
 *
 *	description:	method to execute "ITHLIncrease"
 *	Increment of one unit of the global ITHL register
 *
 *
 */
//+------------------------------------------------------------------
void ImXpad::ithlincrease()
{
	INFO_STREAM << "ImXpad::ithlincrease(): entering... !" << endl;

	//	Add your own code to control device here

    yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());
    try
    {
        m_camera->ITHLIncrease();
    }
    catch (Exception& e)
    {
        ERROR_STREAM << e.getErrMsg() << endl;
        //- throw exception
        Tango::Except::throw_exception("TANGO_DEVICE_ERROR",
                                        e.getErrMsg().c_str(),
                                        "ImXpad::ithlincrease");
    }

}

//+------------------------------------------------------------------
/**
 *	method:	ImXpad::ithldecrease
 *
 *	description:	method to execute "ITHLDecrease"
 *	Decrement of one unit in the global ITHL register
 *
 *
 */
//+------------------------------------------------------------------
void ImXpad::ithldecrease()
{
	INFO_STREAM << "ImXpad::ithldecrease(): entering... !" << endl;

	//	Add your own code to control device here

    yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());
    try
    {
        m_camera->ITHLDecrease();
    }
    catch (Exception& e)
    {
        ERROR_STREAM << e.getErrMsg() << endl;
        //- throw exception
        Tango::Except::throw_exception("TANGO_DEVICE_ERROR",
                                        e.getErrMsg().c_str(),
                                        "ImXpad::ithldecrease");
    }

}







}	//	namespace
