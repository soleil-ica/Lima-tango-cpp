static const char *RcsId = "$Id:  $";
//+=============================================================================
//
// file :         Ufxc.cpp
//
// description :  C++ source for the Ufxc and its commands. 
//                The class is derived from Device. It represents the
//                CORBA servant object which will be accessed from the
//                network. All commands which can be executed on the
//                Ufxc are implemented in this file.
//
// project :      TANGO Device Server
//
// $Author:  $
//
// $Revision:  $
//
// $Revision:  $
// $Date:  $
//
// SVN only:
// $HeadURL: $
//
// CVS only:
// $Source:  $
// $Log:  $
//
// copyleft :    Synchrotron SOLEIL 
//               L'Orme des merisiers - Saint Aubin
//               BP48 - 91192 Gif sur Yvette
//               FRANCE
//
//-=============================================================================
//
//  		This file is generated by POGO
//	(Program Obviously used to Generate tango Object)
//
//         (c) - Software Engineering Group - ESRF
//=============================================================================



//===================================================================
//
//	The following table gives the correspondence
//	between commands and method name.
//
//  Command name    |  Method name
//	----------------------------------------
//  State           |  dev_state()
//  Status          |  dev_status()
//  LoadConfigFile  |  load_config_file()
//
//===================================================================


#include <tango.h>
#include <PogoHelper.h>
#include <Ufxc.h>
#include <UfxcClass.h>

namespace Ufxc_ns
{

//+----------------------------------------------------------------------------
//
// method : 		Ufxc::Ufxc(string &s)
// 
// description : 	constructor for simulated Ufxc
//
// in : - cl : Pointer to the DeviceClass object
//      - s : Device name 
//
//-----------------------------------------------------------------------------
Ufxc::Ufxc(Tango::DeviceClass *cl, string &s)
:Tango::Device_4Impl(cl, s.c_str())
{
	init_device();
}
Ufxc::Ufxc(Tango::DeviceClass *cl, const char *s)
:Tango::Device_4Impl(cl, s)
{
	init_device();
}
Ufxc::Ufxc(Tango::DeviceClass *cl, const char *s, const char *d)
:Tango::Device_4Impl(cl, s, d)
{
	init_device();
}
//+----------------------------------------------------------------------------
//
// method : 		Ufxc::delete_device()
// 
// description : 	will be called at device destruction or at init command.
//
//-----------------------------------------------------------------------------
void Ufxc::delete_device()
{
	DELETE_DEVSTRING_ATTRIBUTE(attr_libVersion_read);
	DELETE_DEVSTRING_ATTRIBUTE(attr_firmwareVersion_read);
	DELETE_SCALAR_ATTRIBUTE(attr_triggerAcquisitionFrequency_read);
	DELETE_SCALAR_ATTRIBUTE(attr_detectorTemperature_read);
	DELETE_SCALAR_ATTRIBUTE(attr_thresholdLow_read);
	DELETE_SCALAR_ATTRIBUTE(attr_thresholdHigh_read);
	DELETE_SCALAR_ATTRIBUTE(attr_thresholdLow1_read);
	DELETE_SCALAR_ATTRIBUTE(attr_thresholdHigh1_read);
	DELETE_SCALAR_ATTRIBUTE(attr_thresholdLow2_read);
	DELETE_SCALAR_ATTRIBUTE(attr_thresholdHigh2_read);
	DELETE_DEVSTRING_ATTRIBUTE(attr_currentAlias_read);
	DELETE_DEVSTRING_ATTRIBUTE(attr_currentConfigFile_read);
	//	Delete device allocated objects

	INFO_STREAM << "Remove the inner-appender." << endl;
    yat4tango::InnerAppender::release(this);

	//!!!! ONLY LimaDetector device can do this !!!!
	//if(m_ct!=0)
	//{
	//    ControlFactory::instance().reset("Ufxc");
	//    m_ct = 0;
	//}    

	// Exit acquisition task
	INFO_STREAM << "Exit yat::DeviceTask." << endl;
	m_my_task.reset();

	m_map_alias_config_files.clear();
}

//+----------------------------------------------------------------------------
//
// method : 		Ufxc::init_device()
// 
// description : 	will be called at device initialization.
//
//-----------------------------------------------------------------------------
void Ufxc::init_device()
{
	INFO_STREAM << "Ufxc::Ufxc() create device " << device_name << endl;

	// Initialise variables to default values
	//--------------------------------------------
	get_device_property();

	CREATE_DEVSTRING_ATTRIBUTE(attr_libVersion_read, MAX_ATTRIBUTE_STRING_LENGTH);
	CREATE_DEVSTRING_ATTRIBUTE(attr_firmwareVersion_read, MAX_ATTRIBUTE_STRING_LENGTH);
	CREATE_SCALAR_ATTRIBUTE(attr_triggerAcquisitionFrequency_read);
	CREATE_SCALAR_ATTRIBUTE(attr_detectorTemperature_read);
	CREATE_SCALAR_ATTRIBUTE(attr_thresholdLow_read);
	CREATE_SCALAR_ATTRIBUTE(attr_thresholdHigh_read);
	CREATE_SCALAR_ATTRIBUTE(attr_thresholdLow1_read);
	CREATE_SCALAR_ATTRIBUTE(attr_thresholdHigh1_read);
	CREATE_SCALAR_ATTRIBUTE(attr_thresholdLow2_read);
	CREATE_SCALAR_ATTRIBUTE(attr_thresholdHigh2_read);
	CREATE_DEVSTRING_ATTRIBUTE(attr_currentAlias_read, 255);
	CREATE_DEVSTRING_ATTRIBUTE(attr_currentConfigFile_read, 255);

	m_is_device_initialized = false;
	set_state(Tango::INIT);
	m_status_message.str("");
	strcpy(*attr_currentAlias_read, "Unknown");
	strcpy(*attr_currentConfigFile_read, "Unknown");

	INFO_STREAM << "Create the inner-appender in order to manage logs." << endl;  
    yat4tango::InnerAppender::initialize(this, 512);

	try
	{
		//- get the main object used to pilot the lima framework
		//in fact LimaDetector is create the singleton control objet
		//so this call, will only return existing object, no need to give it the ip !!
		m_ct = ControlFactory::instance().get_control("Ufxc");

		//- get interface to specific camera
		m_hw = dynamic_cast<lima::Ufxc::Interface*> (m_ct->hwInterface());

		//- get camera to specific detector
		m_camera = &(m_hw->getCamera());
	}
	catch(Exception& e)
	{
		INFO_STREAM << "Initialization Failed : " << e.getErrMsg() << endl;
		m_status_message << "Initialization Failed : " << e.getErrMsg() << endl;
		m_is_device_initialized = false;
		set_state(Tango::FAULT);
		return;
	}
	catch(...)
	{
		INFO_STREAM << "Initialization Failed : UNKNOWN" << endl;
		m_status_message << "Initialization Failed : UNKNOWN" << endl;
		set_state(Tango::FAULT);
		m_is_device_initialized = false;
		return;
	}

	//---------------------------------------------------------
	//- Prepare alias for each configuration file
	//---------------------------------------------------------
	INFO_STREAM << "- Prepare alias for each configuration file" << endl;
	for(size_t i = 0;i < detectorConfigFiles.size();i++)
	{
		yat::StringTokenizer config_files(detectorConfigFiles.at(i), ";");
		string alias = config_files.next_token();
		string file_name = config_files.next_token();
		std::transform(alias.begin(), alias.end(), alias.begin(), ::toupper);
		m_map_alias_config_files.insert(make_pair(alias, file_name));
		INFO_STREAM << "  [alias : " << alias << " , file : " << file_name << endl;
	}

	m_is_device_initialized = true;
	try
	{
		set_state(Tango::DISABLE);
		//- Create the task in order to load_config_file() with last memorized file
		m_my_task.reset(new MyTask(this), TaskExiter());
		m_my_task->go();

		if(autoLoad)
		{
			load_config_file(const_cast<Tango::DevString> (memorizedConfigAlias.c_str()));
		}

		//then write attributes at init with last memorized values
		INFO_STREAM << "Write tango hardware at Init - thresholdLow." << endl;
		Tango::WAttribute &thresholdLow = dev_attr->get_w_attr_by_name("thresholdLow");
		*attr_thresholdLow_read = attr_thresholdLow_write = memorizedThresholdLow;
		thresholdLow.set_write_value(*attr_thresholdLow_read);
		write_thresholdLow(thresholdLow);

		INFO_STREAM << "Write tango hardware at Init - threshold." << endl;
		Tango::WAttribute &thresholdHigh = dev_attr->get_w_attr_by_name("thresholdHigh");
		*attr_thresholdHigh_read = attr_thresholdHigh_write = memorizedThresholdHigh;
		thresholdHigh.set_write_value(*attr_thresholdHigh_read);
		write_thresholdHigh(thresholdHigh);
		/////////
		ImageType image_type;
		m_camera->getImageType(image_type);
		INFO_STREAM << "image_type = " << image_type << endl;

		TrigMode trig_mode;
		m_ct->acquisition()->getTriggerMode(trig_mode);
		INFO_STREAM << "trig_mode = " << trig_mode << endl;

		//available only in mode pump & probe (i.e Trigger Ext Multi and Bpp2)
		if(trig_mode == ExtTrigMult && (image_type==Bpp2 ||image_type==Bpp32))
		{
			INFO_STREAM << "Write tango hardware at Init - triggerAcquisitionFrequency." << endl;
			Tango::WAttribute &triggerAcquisitionFrequency = dev_attr->get_w_attr_by_name("triggerAcquisitionFrequency");
			*attr_triggerAcquisitionFrequency_read = attr_triggerAcquisitionFrequency_write = memorizedTriggerAcquisitionFrequency;
			triggerAcquisitionFrequency.set_write_value(*attr_triggerAcquisitionFrequency_read);
			write_triggerAcquisitionFrequency(triggerAcquisitionFrequency);
		}
		/////////
	}
	catch(Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		m_status_message << "Initialization Failed : ";
		for(unsigned i = 0;i < df.errors.length();i++)
		{
			m_status_message << df.errors[i].desc << endl;
		}
		m_is_device_initialized = false;
		set_state(Tango::FAULT);
		return;
	}
	catch(Exception& e)
	{
		ERROR_STREAM << "Initialization Failed : " << e.getErrMsg() << endl;
		m_status_message << "Initialization Failed : " << e.getErrMsg() << endl;
		m_is_device_initialized = false;
		set_state(Tango::FAULT);
		return;
	}


	dev_state();
}


//+----------------------------------------------------------------------------
//
// method : 		Ufxc::get_device_property()
// 
// description : 	Read the device properties from database.
//
//-----------------------------------------------------------------------------
void Ufxc::get_device_property()
{
	//	Initialize your default values here (if not done with  POGO).
	//------------------------------------------------------------------

	//	Read device properties from database.(Automatic code generation)
	//------------------------------------------------------------------
	Tango::DbData	dev_prop;
	dev_prop.push_back(Tango::DbDatum("AutoLoad"));
	dev_prop.push_back(Tango::DbDatum("DetectorConfigFiles"));
	dev_prop.push_back(Tango::DbDatum("ConfigIpAddress"));
	dev_prop.push_back(Tango::DbDatum("ConfigPort"));
	dev_prop.push_back(Tango::DbDatum("SFP1IpAddress"));
	dev_prop.push_back(Tango::DbDatum("SFP1Port"));
	dev_prop.push_back(Tango::DbDatum("SFP2IpAddress"));
	dev_prop.push_back(Tango::DbDatum("SFP2Port"));
	dev_prop.push_back(Tango::DbDatum("SFP3IpAddress"));
	dev_prop.push_back(Tango::DbDatum("SFP3Port"));
	dev_prop.push_back(Tango::DbDatum("Timeout"));
	dev_prop.push_back(Tango::DbDatum("GeometricalCorrectionEnabled"));
	dev_prop.push_back(Tango::DbDatum("StackFramesSumEnabled"));
	dev_prop.push_back(Tango::DbDatum("MemorizedThresholdLow"));
	dev_prop.push_back(Tango::DbDatum("MemorizedThresholdHigh"));
	dev_prop.push_back(Tango::DbDatum("MemorizedConfigAlias"));
	dev_prop.push_back(Tango::DbDatum("MemorizedTriggerAcquisitionFrequency"));

	//	Call database and extract values
	//--------------------------------------------
	if (Tango::Util::instance()->_UseDb==true)
		get_db_device()->get_property(dev_prop);
	Tango::DbDatum	def_prop, cl_prop;
	UfxcClass	*ds_class =
		(static_cast<UfxcClass *>(get_device_class()));
	int	i = -1;

	//	Try to initialize AutoLoad from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  autoLoad;
	else {
		//	Try to initialize AutoLoad from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  autoLoad;
	}
	//	And try to extract AutoLoad value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  autoLoad;

	//	Try to initialize DetectorConfigFiles from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  detectorConfigFiles;
	else {
		//	Try to initialize DetectorConfigFiles from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  detectorConfigFiles;
	}
	//	And try to extract DetectorConfigFiles value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  detectorConfigFiles;

	//	Try to initialize ConfigIpAddress from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  configIpAddress;
	else {
		//	Try to initialize ConfigIpAddress from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  configIpAddress;
	}
	//	And try to extract ConfigIpAddress value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  configIpAddress;

	//	Try to initialize ConfigPort from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  configPort;
	else {
		//	Try to initialize ConfigPort from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  configPort;
	}
	//	And try to extract ConfigPort value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  configPort;

	//	Try to initialize SFP1IpAddress from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  sFP1IpAddress;
	else {
		//	Try to initialize SFP1IpAddress from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  sFP1IpAddress;
	}
	//	And try to extract SFP1IpAddress value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  sFP1IpAddress;

	//	Try to initialize SFP1Port from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  sFP1Port;
	else {
		//	Try to initialize SFP1Port from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  sFP1Port;
	}
	//	And try to extract SFP1Port value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  sFP1Port;

	//	Try to initialize SFP2IpAddress from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  sFP2IpAddress;
	else {
		//	Try to initialize SFP2IpAddress from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  sFP2IpAddress;
	}
	//	And try to extract SFP2IpAddress value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  sFP2IpAddress;

	//	Try to initialize SFP2Port from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  sFP2Port;
	else {
		//	Try to initialize SFP2Port from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  sFP2Port;
	}
	//	And try to extract SFP2Port value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  sFP2Port;

	//	Try to initialize SFP3IpAddress from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  sFP3IpAddress;
	else {
		//	Try to initialize SFP3IpAddress from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  sFP3IpAddress;
	}
	//	And try to extract SFP3IpAddress value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  sFP3IpAddress;

	//	Try to initialize SFP3Port from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  sFP3Port;
	else {
		//	Try to initialize SFP3Port from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  sFP3Port;
	}
	//	And try to extract SFP3Port value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  sFP3Port;

	//	Try to initialize Timeout from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  timeout;
	else {
		//	Try to initialize Timeout from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  timeout;
	}
	//	And try to extract Timeout value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  timeout;

	//	Try to initialize GeometricalCorrectionEnabled from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  geometricalCorrectionEnabled;
	else {
		//	Try to initialize GeometricalCorrectionEnabled from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  geometricalCorrectionEnabled;
	}
	//	And try to extract GeometricalCorrectionEnabled value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  geometricalCorrectionEnabled;

	//	Try to initialize StackFramesSumEnabled from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  stackFramesSumEnabled;
	else {
		//	Try to initialize StackFramesSumEnabled from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  stackFramesSumEnabled;
	}
	//	And try to extract StackFramesSumEnabled value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  stackFramesSumEnabled;

	//	Try to initialize MemorizedThresholdLow from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  memorizedThresholdLow;
	else {
		//	Try to initialize MemorizedThresholdLow from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  memorizedThresholdLow;
	}
	//	And try to extract MemorizedThresholdLow value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  memorizedThresholdLow;

	//	Try to initialize MemorizedThresholdHigh from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  memorizedThresholdHigh;
	else {
		//	Try to initialize MemorizedThresholdHigh from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  memorizedThresholdHigh;
	}
	//	And try to extract MemorizedThresholdHigh value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  memorizedThresholdHigh;

	//	Try to initialize MemorizedConfigAlias from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  memorizedConfigAlias;
	else {
		//	Try to initialize MemorizedConfigAlias from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  memorizedConfigAlias;
	}
	//	And try to extract MemorizedConfigAlias value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  memorizedConfigAlias;

	//	Try to initialize MemorizedTriggerAcquisitionFrequency from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  memorizedTriggerAcquisitionFrequency;
	else {
		//	Try to initialize MemorizedTriggerAcquisitionFrequency from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  memorizedTriggerAcquisitionFrequency;
	}
	//	And try to extract MemorizedTriggerAcquisitionFrequency value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  memorizedTriggerAcquisitionFrequency;



	//	End of Automatic code generation
	//------------------------------------------------------------------
	PropertyHelper::create_property_if_empty(this, dev_prop, "False", "AutoLoad");
	PropertyHelper::create_property_if_empty(this, dev_prop, "ALIAS;PATH_AND_FILE_NAME", "DetectorConfigFiles");	
	PropertyHelper::create_property_if_empty(this, dev_prop, "127.0.0.1", "ConfigIpAddress");
	PropertyHelper::create_property_if_empty(this, dev_prop, "0", "ConfigPort");
	PropertyHelper::create_property_if_empty(this, dev_prop, "127.0.0.1", "SFP1IpAddress");
	PropertyHelper::create_property_if_empty(this, dev_prop, "0", "SFP1Port");
	PropertyHelper::create_property_if_empty(this, dev_prop, "127.0.0.1", "SFP2IpAddress");
	PropertyHelper::create_property_if_empty(this, dev_prop, "0", "SFP2Port");
	PropertyHelper::create_property_if_empty(this, dev_prop, "127.0.0.1", "SFP3IpAddress");
	PropertyHelper::create_property_if_empty(this, dev_prop, "0", "SFP3Port");
	PropertyHelper::create_property_if_empty(this, dev_prop, "0", "Timeout");		
	PropertyHelper::create_property_if_empty(this, dev_prop, "true", "GeometricalCorrectionEnabled");
	PropertyHelper::create_property_if_empty(this, dev_prop, "true", "StackFramesSumEnabled");
	PropertyHelper::create_property_if_empty(this, dev_prop, "0", "MemorizedThresholdLow");
	PropertyHelper::create_property_if_empty(this, dev_prop, "0", "MemorizedThresholdHigh");
	PropertyHelper::create_property_if_empty(this, dev_prop, "0", "MemorizedTriggerAcquisitionFrequency");

}
//+----------------------------------------------------------------------------
//
// method : 		Ufxc::always_executed_hook()
// 
// description : 	method always executed before any command is executed
//
//-----------------------------------------------------------------------------
void Ufxc::always_executed_hook()
{
	try
	{
		yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());
		m_status_message.str("");
		//- get the singleton control objet used to pilot the lima framework
		m_ct = ControlFactory::instance().get_control("Ufxc");

		//- get interface to specific camera
		m_hw = dynamic_cast<lima::Ufxc::Interface*> (m_ct->hwInterface());

		//- get camera to specific detector
		m_camera = &(m_hw->getCamera());

		//update state
		dev_state();
	}
	catch(Exception& e)
	{
		ERROR_STREAM << e.getErrMsg() << endl;
		m_status_message << "Initialization Failed : " << e.getErrMsg() << endl;
		//- throw exception
		set_state(Tango::FAULT);
		m_is_device_initialized = false;
		return;
	}
	catch(...)
	{
		ERROR_STREAM << "Initialization Failed : UNKNOWN" << endl;
		m_status_message << "Initialization Failed : UNKNOWN" << endl;
		//- throw exception
		set_state(Tango::FAULT);
		m_is_device_initialized = false;
		return;
	}
}
//+----------------------------------------------------------------------------
//
// method : 		Ufxc::read_attr_hardware
// 
// description : 	Hardware acquisition for attributes.
//
//-----------------------------------------------------------------------------
void Ufxc::read_attr_hardware(vector<long> &attr_list)
{
	DEBUG_STREAM << "Ufxc::read_attr_hardware(vector<long> &attr_list) entering... " << endl;
	//	Add your own code here
}
//+----------------------------------------------------------------------------
//
// method : 		Ufxc::read_triggerAcquisitionFrequency
// 
// description : 	Extract real attribute values for triggerAcquisitionFrequency acquisition result.
//
//-----------------------------------------------------------------------------
void Ufxc::read_triggerAcquisitionFrequency(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Ufxc::read_triggerAcquisitionFrequency(Tango::Attribute &attr) entering... " << endl;
	yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());
	try
	{
		*attr_triggerAcquisitionFrequency_read = attr_triggerAcquisitionFrequency_write;
		attr.set_value(attr_triggerAcquisitionFrequency_read);
	}
	catch(Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		RETHROW_DEVFAILED(df,
						"TANGO_DEVICE_ERROR",
						string(df.errors[0].desc).c_str(),
						"Ufxc::read_triggerAcquisitionFrequency");
	}
}

//+----------------------------------------------------------------------------
//
// method : 		Ufxc::write_triggerAcquisitionFrequency
// 
// description : 	Write triggerAcquisitionFrequency attribute values to hardware.
//
//-----------------------------------------------------------------------------
void Ufxc::write_triggerAcquisitionFrequency(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "Ufxc::write_triggerAcquisitionFrequency(Tango::WAttribute &attr) entering... " << endl;
	yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());
	try
	{
		attr.get_write_value(attr_triggerAcquisitionFrequency_write);
		ImageType image_type;
		m_camera->getImageType(image_type);
		DEBUG_STREAM << "image_type = " << image_type << endl;

		TrigMode trig_mode;
		m_ct->acquisition()->getTriggerMode(trig_mode);
		DEBUG_STREAM << "trig_mode = " << trig_mode << endl;

		//available only in mode pump & probe (i.e Trigger Ext Multi and Bpp2)
		if(trig_mode == ExtTrigMult && (image_type==Bpp2 ||image_type==Bpp32))
		{
			double exposure;
			m_ct->acquisition()->getAcqExpoTime(exposure);
			int nb_frames_pump_probe = static_cast<int> (round(exposure * attr_triggerAcquisitionFrequency_write / 2)*2);
			INFO_STREAM << "nb_frames_pump_probe = " << nb_frames_pump_probe << endl;
			m_camera->set_pump_probe_trigger_acquisition_frequency(attr_triggerAcquisitionFrequency_write);
			m_camera->set_pump_probe_nb_frames(nb_frames_pump_probe);
			m_ct->acquisition()->setAcqNbFrames(stackFramesSumEnabled?1:nb_frames_pump_probe);
			PropertyHelper::set_property(this, "MemorizedTriggerAcquisitionFrequency", attr_triggerAcquisitionFrequency_write);
		}
		else
		{
			//- throw exception
			THROW_DEVFAILED("CONFIGURATION_ERROR",
							"triggerAcquisitionFrequency is used to compute the nbFrames to acquire according to the exposureTime.\n"
							"This functionnality is available only in 'pump & probe mode' (i.e Trigger External Multi & 2 bits).\n",
							"Ufxc::write_triggerAcquisitionFrequency");
		}
	}
	catch(Exception& e)
	{
		ERROR_STREAM << e.getErrMsg() << endl;
		//- throw exception
		THROW_DEVFAILED("TANGO_DEVICE_ERROR",
						e.getErrMsg().c_str(),
						"Ufxc::write_triggerAcquisitionFrequency");
	}
	catch(Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		RETHROW_DEVFAILED(df,
						"TANGO_DEVICE_ERROR",
						string(df.errors[0].desc).c_str(),
						"Ufxc::write_triggerAcquisitionFrequency");
	}
}

//+----------------------------------------------------------------------------
//
// method : 		Ufxc::read_currentAlias
// 
// description : 	Extract real attribute values for currentAlias acquisition result.
//
//-----------------------------------------------------------------------------
void Ufxc::read_currentAlias(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Ufxc::read_currentAlias(Tango::Attribute &attr) entering... " << endl;
	try
	{
		attr.set_value(attr_currentAlias_read);
	}
	catch(Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		RETHROW_DEVFAILED(df,
						"TANGO_DEVICE_ERROR",
						string(df.errors[0].desc).c_str(),
						"Ufxc::read_currentAlias()");
	}
}

//+----------------------------------------------------------------------------
//
// method : 		Ufxc::read_currentConfigFile
// 
// description : 	Extract real attribute values for currentConfigFile acquisition result.
//
//-----------------------------------------------------------------------------
void Ufxc::read_currentConfigFile(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Ufxc::read_currentConfigFile(Tango::Attribute &attr) entering... " << endl;
	try
	{
		attr.set_value(attr_currentConfigFile_read);
	}
	catch(Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		RETHROW_DEVFAILED(df,
						"TANGO_DEVICE_ERROR",
						string(df.errors[0].desc).c_str(),
						"Ufxc::read_currentConfigFile()");
	}
}


//+----------------------------------------------------------------------------
//
// method : 		Ufxc::read_thresholdLow1
// 
// description : 	Extract real attribute values for thresholdLow1 acquisition result.
//
//-----------------------------------------------------------------------------
void Ufxc::read_thresholdLow1(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Ufxc::read_thresholdLow1(Tango::Attribute &attr) entering... " << endl;

	yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());
	try
	{
		unsigned long thr = 0;
		m_camera->get_threshold_Low1(thr);
		*attr_thresholdLow1_read = thr;
		attr.set_value(attr_thresholdLow1_read);
	}
	catch(Exception& e)
	{
		ERROR_STREAM << e.getErrMsg() << endl;
		//- throw exception
		THROW_DEVFAILED("TANGO_DEVICE_ERROR",
						e.getErrMsg().c_str(),
						"Ufxc::read_thresholdLow1");
	}
	catch(Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		RETHROW_DEVFAILED(df,
						"TANGO_DEVICE_ERROR",
						string(df.errors[0].desc).c_str(),
						"Ufxc::read_thresholdLow1");
	}
}

//+----------------------------------------------------------------------------
//
// method : 		Ufxc::read_thresholdHigh1
// 
// description : 	Extract real attribute values for thresholdHigh1 acquisition result.
//
//-----------------------------------------------------------------------------
void Ufxc::read_thresholdHigh1(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Ufxc::read_thresholdHigh1(Tango::Attribute &attr) entering... " << endl;
	yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());
	try
	{
		unsigned long thr = 0;
		m_camera->get_threshold_High1(thr);
		*attr_thresholdHigh1_read = thr;
		attr.set_value(attr_thresholdHigh1_read);
	}
	catch(Exception& e)
	{
		ERROR_STREAM << e.getErrMsg() << endl;
		//- throw exception
		THROW_DEVFAILED("TANGO_DEVICE_ERROR",
						e.getErrMsg().c_str(),
						"Ufxc::read_thresholdHigh1");
	}
	catch(Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		RETHROW_DEVFAILED(df,
						"TANGO_DEVICE_ERROR",
						string(df.errors[0].desc).c_str(),
						"Ufxc::read_thresholdHigh1");
	}
}

//+----------------------------------------------------------------------------
//
// method : 		Ufxc::read_thresholdLow2
// 
// description : 	Extract real attribute values for thresholdLow2 acquisition result.
//
//-----------------------------------------------------------------------------
void Ufxc::read_thresholdLow2(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Ufxc::read_thresholdLow2(Tango::Attribute &attr) entering... " << endl;
	yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());
	try
	{
		unsigned long thr = 0;
		m_camera->get_threshold_Low2(thr);
		*attr_thresholdLow2_read = thr;
		attr.set_value(attr_thresholdLow2_read);
	}
	catch(Exception& e)
	{
		ERROR_STREAM << e.getErrMsg() << endl;
		//- throw exception
		THROW_DEVFAILED("TANGO_DEVICE_ERROR",
						e.getErrMsg().c_str(),
						"Ufxc::read_thresholdLow2");
	}
	catch(Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		RETHROW_DEVFAILED(df,
						"TANGO_DEVICE_ERROR",
						string(df.errors[0].desc).c_str(),
						"Ufxc::read_thresholdLow2");
	}
}

//+----------------------------------------------------------------------------
//
// method : 		Ufxc::read_thresholdHigh2
// 
// description : 	Extract real attribute values for thresholdHigh2 acquisition result.
//
//-----------------------------------------------------------------------------
void Ufxc::read_thresholdHigh2(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Ufxc::read_thresholdHigh2(Tango::Attribute &attr) entering... " << endl;
	yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());
	try
	{
		unsigned long thr = 0;
		m_camera->get_threshold_High2(thr);
		*attr_thresholdHigh2_read = thr;
		attr.set_value(attr_thresholdHigh2_read);
	}
	catch(Exception& e)
	{
		ERROR_STREAM << e.getErrMsg() << endl;
		//- throw exception
		THROW_DEVFAILED("TANGO_DEVICE_ERROR",
						e.getErrMsg().c_str(),
						"Ufxc::read_thresholdHigh2");
	}
	catch(Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		RETHROW_DEVFAILED(df,
						"TANGO_DEVICE_ERROR",
						string(df.errors[0].desc).c_str(),
						"Ufxc::read_thresholdHigh2");
	}
}

//+----------------------------------------------------------------------------
//
// method : 		Ufxc::read_thresholdLow
// 
// description : 	Extract real attribute values for thresholdLow acquisition result.
//
//-----------------------------------------------------------------------------
void Ufxc::read_thresholdLow(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Ufxc::read_thresholdLow(Tango::Attribute &attr) entering... " << endl;
	yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());
	try
	{
		*attr_thresholdLow_read = attr_thresholdLow_write;
		attr.set_value(attr_thresholdLow_read);
	}
	catch(Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		RETHROW_DEVFAILED(df,
						"TANGO_DEVICE_ERROR",
						string(df.errors[0].desc).c_str(),
						"Ufxc::read_thresholdLow");
	}
}

//+----------------------------------------------------------------------------
//
// method : 		Ufxc::write_thresholdLow
// 
// description : 	Write thresholdLow attribute values to hardware.
//
//-----------------------------------------------------------------------------
void Ufxc::write_thresholdLow(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "Ufxc::write_thresholdLow(Tango::WAttribute &attr) entering... " << endl;
	yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());
	try
	{
		attr.get_write_value(attr_thresholdLow_write);
		m_camera->set_threshold_Low1(attr_thresholdLow_write);
		m_camera->set_threshold_Low2(attr_thresholdLow_write);
		PropertyHelper::set_property(this, "MemorizedThresholdLow", attr_thresholdLow_write);
	}
	catch(Exception& e)
	{
		ERROR_STREAM << e.getErrMsg() << endl;
		//- throw exception
		THROW_DEVFAILED("TANGO_DEVICE_ERROR",
						e.getErrMsg().c_str(),
						"Ufxc::write_thresholdLow");
	}
	catch(Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		RETHROW_DEVFAILED(df,
						"TANGO_DEVICE_ERROR",
						string(df.errors[0].desc).c_str(),
						"Ufxc::write_thresholdLow");
	}
}

//+----------------------------------------------------------------------------
//
// method : 		Ufxc::read_thresholdHigh
// 
// description : 	Extract real attribute values for thresholdHigh acquisition result.
//
//-----------------------------------------------------------------------------
void Ufxc::read_thresholdHigh(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Ufxc::read_thresholdHigh(Tango::Attribute &attr) entering... " << endl;
	yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());
	try
	{
		*attr_thresholdHigh_read = attr_thresholdHigh_write;
		attr.set_value(attr_thresholdHigh_read);
	}
	catch(Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		RETHROW_DEVFAILED(df,
						"TANGO_DEVICE_ERROR",
						string(df.errors[0].desc).c_str(),
						"Ufxc::read_thresholdHigh");
	}
}

//+----------------------------------------------------------------------------
//
// method : 		Ufxc::write_thresholdHigh
// 
// description : 	Write thresholdHigh attribute values to hardware.
//
//-----------------------------------------------------------------------------
void Ufxc::write_thresholdHigh(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "Ufxc::write_thresholdHigh(Tango::WAttribute &attr) entering... " << endl;
	yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());
	try
	{
		attr.get_write_value(attr_thresholdHigh_write);
		m_camera->set_threshold_High1(attr_thresholdHigh_write);
		m_camera->set_threshold_High2(attr_thresholdHigh_write);
		PropertyHelper::set_property(this, "MemorizedThresholdHigh", attr_thresholdHigh_write);
	}
	catch(Exception& e)
	{
		ERROR_STREAM << e.getErrMsg() << endl;
		//- throw exception
		THROW_DEVFAILED("TANGO_DEVICE_ERROR",
						e.getErrMsg().c_str(),
						"Ufxc::write_thresholdHigh");
	}
	catch(Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		RETHROW_DEVFAILED(df,
						"TANGO_DEVICE_ERROR",
						string(df.errors[0].desc).c_str(),
						"Ufxc::write_thresholdHigh");
	}
}

//+----------------------------------------------------------------------------
//
// method : 		Ufxc::read_detectorTemperature
// 
// description : 	Extract real attribute values for detectorTemperature acquisition result.
//
//-----------------------------------------------------------------------------
void Ufxc::read_detectorTemperature(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Ufxc::read_detectorTemperature(Tango::Attribute &attr) entering... " << endl;
	yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());
	try
	{
		unsigned long temp = 0;
		m_camera->get_detector_temperature(temp);
		*attr_detectorTemperature_read = temp;
		attr.set_value(attr_detectorTemperature_read);
	}
	catch(Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		RETHROW_DEVFAILED(df,
						"TANGO_DEVICE_ERROR",
						string(df.errors[0].desc).c_str(),
						"Ufxc::read_detectorTemperature");
	}
	catch(Exception& e)
	{
		ERROR_STREAM << e.getErrMsg() << endl;
		//- throw exception
		THROW_DEVFAILED("TANGO_DEVICE_ERROR",
						e.getErrMsg().c_str(),
						"Ufxc::read_detectorTemperature");
	}
}

//+----------------------------------------------------------------------------
//
// method : 		Ufxc::read_firmwareVersion
// 
// description : 	Extract real attribute values for firmwareVersion acquisition result.
//
//-----------------------------------------------------------------------------
void Ufxc::read_firmwareVersion(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Ufxc::read_firmwareVersion(Tango::Attribute &attr) entering... " << endl;
	yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());
	try
	{
		std::string version("?.?.?");
		m_camera->get_firmware_version(version);
		strcpy(*attr_firmwareVersion_read, version.c_str());

		attr.set_value(attr_firmwareVersion_read);
	}
	catch(Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		RETHROW_DEVFAILED(df,
						"TANGO_DEVICE_ERROR",
						string(df.errors[0].desc).c_str(),
						"Ufxc::read_firmwareVersion");
	}
	catch(Exception& e)
	{
		ERROR_STREAM << e.getErrMsg() << endl;
		//- throw exception
		THROW_DEVFAILED("TANGO_DEVICE_ERROR",
						e.getErrMsg().c_str(),
						"Ufxc::read_firmwareVersion");
	}
}

//+----------------------------------------------------------------------------
//
// method : 		Ufxc::read_libVersion
// 
// description : 	Extract real attribute values for libVersion acquisition result.
//
//-----------------------------------------------------------------------------
void Ufxc::read_libVersion(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Ufxc::read_libVersion(Tango::Attribute &attr) entering... " << endl;
	yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());
	try
	{
		std::string version("?.?.?");
		m_camera->get_lib_version(version);
		strcpy(*attr_libVersion_read, version.c_str());

		attr.set_value(attr_libVersion_read);
	}
	catch(Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		RETHROW_DEVFAILED(df,
						"TANGO_DEVICE_ERROR",
						string(df.errors[0].desc).c_str(),
						"Ufxc::read_libVersion");
	}
	catch(Exception& e)
	{
		ERROR_STREAM << e.getErrMsg() << endl;
		//- throw exception
		THROW_DEVFAILED("TANGO_DEVICE_ERROR",
						e.getErrMsg().c_str(),
						"Ufxc::read_libVersion");
	}
}


//+------------------------------------------------------------------
/**
 *    method:    Ufxc::dev_state
 *
 *    description:    method to execute "State"
 *    This command gets the device state (stored in its <i>device_state</i> data member) and returns it to the caller.
 *
 * @return    State Code
 *
 */
//+------------------------------------------------------------------
Tango::DevState Ufxc::dev_state()
{
	Tango::DevState argout = DeviceImpl::dev_state();
	DEBUG_STREAM << "Ufxc::dev_state(): entering... !" << endl;

	//    Add your own code to control device here
	stringstream DeviceStatus;
	DeviceStatus << "";
	Tango::DevState DeviceState = Tango::STANDBY;
	if(!m_is_device_initialized)
	{
		DeviceState = Tango::FAULT;
		DeviceStatus << m_status_message.str();
	}
	else
	{
		// state & status are retrieved from Factory, Factory is updated by Generic device
		DeviceState = ControlFactory::instance().get_state();
		DeviceStatus << ControlFactory::instance().get_status();
	}

	set_state(DeviceState);
	set_status(DeviceStatus.str());

	argout = DeviceState;

	return argout;
}


//+------------------------------------------------------------------
/**
 *	method:	Ufxc::load_config_file
 *
 *	description:	method to execute "LoadConfigFile"
 *
 * @param	argin	alias of the Detector configuration file
 *
 */
//+------------------------------------------------------------------
void Ufxc::load_config_file(Tango::DevString argin)
{
	DEBUG_STREAM << "Ufxc::load_config_file(): entering... !" << endl;

	//	Add your own code to control device here
	yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());
	try
	{
		//  in the property parser "ALIAS;c:\mondossier\monfichier.ini"
		std::string alias = argin;
		std::transform(alias.begin(), alias.end(), alias.begin(), ::toupper);
		//check if alias exist !
		map<std::string, std::string>::const_iterator it = m_map_alias_config_files.find(alias);
		if(it == m_map_alias_config_files.end())
		{
			stringstream ss;
			ss << "Unable to find the alias [" << alias << "]" << endl;
			THROW_DEVFAILED("TANGO_DEVICE_ERROR",
							ss.str().c_str(),
							"Ufxc::load_config_file()");
		}

		//ask the camera to load the file on the board
		//- create an msg to pass it some data (Conf)
		INFO_STREAM << "Load the detector config file : " << m_map_alias_config_files[alias] << std::endl;
		m_my_task->load_config_file(m_camera, m_map_alias_config_files[alias]);

		//update attributes related to config ini file
		strcpy(*attr_currentAlias_read, alias.c_str());
		strcpy(*attr_currentConfigFile_read, (m_map_alias_config_files[alias].c_str()));
		yat4tango::PropertyHelper::set_property(this, "MemorizedConfigAlias", alias);
	}
	catch(Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		RETHROW_DEVFAILED(df,
						"TANGO_DEVICE_ERROR",
						string(df.errors[0].desc).c_str(),
						"Ufxc::load_config_file()");
	}
	catch(Exception& e)
	{
		ERROR_STREAM << e.getErrMsg() << endl;
		//- throw exception
		THROW_DEVFAILED("TANGO_DEVICE_ERROR",
						e.getErrMsg().c_str(),
						"Ufxc::load_config_file");
	}
}



}	//	namespace
