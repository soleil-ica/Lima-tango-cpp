static const char *RcsId = "$Id:  $";
//+=============================================================================
//
// file :         FitGaussian.cpp
//
// description :  C++ source for the FitGaussian and its commands. 
//                The class is derived from Device. It represents the
//                CORBA servant object which will be accessed from the
//                network. All commands which can be executed on the
//                FitGaussian are implemented in this file.
//
// project :      TANGO Device Server
//
// $Author:  $
//
// $Revision:  $
//
// $Revision:  $
// $Date:  $
//
// SVN only:
// $HeadURL: $
//
// CVS only:
// $Source:  $
// $Log:  $
//
// copyleft :    Synchrotron SOLEIL 
//               L'Orme des merisiers - Saint Aubin
//               BP48 - 91192 Gif sur Yvette
//               FRANCE
//
//-=============================================================================
//
//  		This file is generated by POGO
//	(Program Obviously used to Generate tango Object)
//
//         (c) - Software Engineering Group - ESRF
//=============================================================================



//===================================================================
//
//	The following table gives the correspondence
//	between commands and method name.
//
//  Command name|  Method name
//	----------------------------------------
//  State   |  dev_state()
//  Status  |  dev_status()
//
//===================================================================


#include <tango.h>
#include <PogoHelper.h>
#include <FitGaussian.h>
#include <FitGaussianClass.h>

namespace FitGaussian_ns
{

//+----------------------------------------------------------------------------
//
// method : 		FitGaussian::FitGaussian(string &s)
// 
// description : 	constructor for simulated FitGaussian
//
// in : - cl : Pointer to the DeviceClass object
//      - s : Device name 
//
//-----------------------------------------------------------------------------
FitGaussian::FitGaussian(Tango::DeviceClass *cl,string &s)
:Tango::Device_4Impl(cl,s.c_str())
{
	init_device();
}

FitGaussian::FitGaussian(Tango::DeviceClass *cl,const char *s)
:Tango::Device_4Impl(cl,s)
{
	init_device();
}

FitGaussian::FitGaussian(Tango::DeviceClass *cl,const char *s,const char *d)
:Tango::Device_4Impl(cl,s,d)
{
	init_device();
}
//+----------------------------------------------------------------------------
//
// method : 		FitGaussian::delete_device()
// 
// description : 	will be called at device destruction or at init command.
//
//-----------------------------------------------------------------------------
void FitGaussian::delete_device()
{
	//	Delete device allocated objects
	yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());	
	DELETE_DEVSTRING_ATTRIBUTE(attr_operationType_read);
	DELETE_DEVSTRING_ATTRIBUTE(attr_version_read);
	
	DELETE_SCALAR_ATTRIBUTE(attr_AutoROIFound_read);
	DELETE_SCALAR_ATTRIBUTE(attr_AutoROIOriginX_read);
	DELETE_SCALAR_ATTRIBUTE(attr_AutoROIOriginY_read);
	DELETE_SCALAR_ATTRIBUTE(attr_AutoROIWidth_read);
	DELETE_SCALAR_ATTRIBUTE(attr_AutoROIHeight_read);

	DELETE_SCALAR_ATTRIBUTE(attr_XProjFitConverged_read);
	DELETE_SCALAR_ATTRIBUTE(attr_XProjFitCenter_read);
	DELETE_SCALAR_ATTRIBUTE(attr_XProjFitMag_read);
	DELETE_SCALAR_ATTRIBUTE(attr_XProjFitSigma_read);
	DELETE_SCALAR_ATTRIBUTE(attr_XProjFitFWHM_read);
	DELETE_SCALAR_ATTRIBUTE(attr_XProjFitBG_read);
	DELETE_SCALAR_ATTRIBUTE(attr_XProjFitChi2_read);

	DELETE_SCALAR_ATTRIBUTE(attr_YProjFitConverged_read);
	DELETE_SCALAR_ATTRIBUTE(attr_YProjFitCenter_read);
	DELETE_SCALAR_ATTRIBUTE(attr_YProjFitMag_read);
	DELETE_SCALAR_ATTRIBUTE(attr_YProjFitSigma_read);
	DELETE_SCALAR_ATTRIBUTE(attr_YProjFitFWHM_read);
	DELETE_SCALAR_ATTRIBUTE(attr_YProjFitBG_read);
	DELETE_SCALAR_ATTRIBUTE(attr_YProjFitChi2_read);	

	DELETE_DEVSTRING_ATTRIBUTE(attr_myPushTime_read);	
}

//+----------------------------------------------------------------------------
//
// method : 		FitGaussian::init_device()
// 
// description : 	will be called at device initialization.
//
//-----------------------------------------------------------------------------
void FitGaussian::init_device()
{
	INFO_STREAM << "FitGaussian::FitGaussian() create device " << device_name << endl;
	yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());
	// Initialise variables to default values
	//--------------------------------------------
	get_device_property();

	CREATE_DEVSTRING_ATTRIBUTE(attr_operationType_read, MAX_ATTRIBUTE_STRING_LENGTH);
	CREATE_DEVSTRING_ATTRIBUTE(attr_version_read, MAX_ATTRIBUTE_STRING_LENGTH);

	CREATE_SCALAR_ATTRIBUTE(attr_AutoROIFound_read, false);
	CREATE_SCALAR_ATTRIBUTE(attr_AutoROIOriginX_read);
	CREATE_SCALAR_ATTRIBUTE(attr_AutoROIOriginY_read);
	CREATE_SCALAR_ATTRIBUTE(attr_AutoROIWidth_read);
	CREATE_SCALAR_ATTRIBUTE(attr_AutoROIHeight_read);

	CREATE_SCALAR_ATTRIBUTE(attr_XProjFitConverged_read, false);
	CREATE_SCALAR_ATTRIBUTE(attr_XProjFitCenter_read, 0.0);
	CREATE_SCALAR_ATTRIBUTE(attr_XProjFitMag_read, 0.0);
	CREATE_SCALAR_ATTRIBUTE(attr_XProjFitSigma_read, 0.0);
	CREATE_SCALAR_ATTRIBUTE(attr_XProjFitFWHM_read, 0.0);
	CREATE_SCALAR_ATTRIBUTE(attr_XProjFitBG_read, 0.0);
	CREATE_SCALAR_ATTRIBUTE(attr_XProjFitChi2_read, 0.0);

	CREATE_SCALAR_ATTRIBUTE(attr_YProjFitConverged_read, false);
	CREATE_SCALAR_ATTRIBUTE(attr_YProjFitCenter_read, 0.0);
	CREATE_SCALAR_ATTRIBUTE(attr_YProjFitMag_read, 0.0);
	CREATE_SCALAR_ATTRIBUTE(attr_YProjFitSigma_read, 0.0);
	CREATE_SCALAR_ATTRIBUTE(attr_YProjFitFWHM_read, 0.0);
	CREATE_SCALAR_ATTRIBUTE(attr_YProjFitBG_read, 0.0);
	CREATE_SCALAR_ATTRIBUTE(attr_YProjFitChi2_read, 0.0);

	CREATE_DEVSTRING_ATTRIBUTE(attr_myPushTime_read, MAX_ATTRIBUTE_STRING_LENGTH);	

    //By default INIT, need to ensure that all objets are OK before set the device to STANDBY
    set_state(Tango::INIT);
    m_is_device_initialized = false;
    m_status_message.str("");	
	m_fit_task = nullptr;
	delete m_fit_task;
    m_ct = 0;
	
    try
    {
        //- get the main object used to pilot the lima framework
        //in fact LimaDetector is create the singleton control objet
        //so this call, will only return existing object!
        m_ct = ControlFactory::instance().get_control("FitGaussian");
    }
    catch (Exception& e)
    {
        INFO_STREAM << "Initialization Failed 1: " << e.getErrMsg() << endl;
        m_status_message << "Initialization Failed : " << e.getErrMsg() << endl;
        m_is_device_initialized = false;
        set_state(Tango::FAULT);
        return;
    }
    catch (...)
    {
        INFO_STREAM << "Initialization Failed : UNKNOWN" << endl;
        m_status_message << "Initialization Failed : UNKNOWN" << endl;
        set_state(Tango::FAULT);
        m_is_device_initialized = false;
        return;
    }

    m_is_device_initialized = true;

	//write at init, only if device is correctly initialized
    if (m_is_device_initialized)
    {
		// AddOp()
		INFO_STREAM << "Write tango hardware at Init - Add Operations to the processLib." << endl;
		m_operation_type = memorizedOperationType;
		delete_external_operation(memorizedOperationLevel);		
		m_map_operations.clear();
		add_external_operation(memorizedOperationLevel);  

		INFO_STREAM << "Write tango hardware at Init - autoROIEnabled." << endl;
		Tango::WAttribute &auto_roi = dev_attr->get_w_attr_by_name("AutoROIEnabled");
		attr_AutoROIEnabled_write = autoROIEnabled;
		auto_roi.set_write_value(autoROIEnabled);
		write_AutoROIEnabled(auto_roi);		

		INFO_STREAM << "Write tango hardware at Init - xProjEnabled." << endl;
		Tango::WAttribute &xproj_enabled = dev_attr->get_w_attr_by_name("XProjEnabled");
		attr_XProjEnabled_write = xProjEnabled;
		xproj_enabled.set_write_value(xProjEnabled);
		write_XProjEnabled(xproj_enabled);

		INFO_STREAM << "Write tango hardware at Init - yProjEnabled." << endl;
		Tango::WAttribute &yproj_enabled = dev_attr->get_w_attr_by_name("YProjEnabled");
		attr_YProjEnabled_write = yProjEnabled;
		yproj_enabled.set_write_value(yProjEnabled);
		write_YProjEnabled(yproj_enabled);
			

	}
}

//+----------------------------------------------------------------------------
//
// method : 		FitGaussian::get_device_property()
// 
// description : 	Read the device properties from database.
//
//-----------------------------------------------------------------------------
void FitGaussian::get_device_property()
{
	//	Initialize your default values here (if not done with  POGO).
	//------------------------------------------------------------------
	yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());
	//	Read device properties from database.(Automatic code generation)
	//------------------------------------------------------------------
	Tango::DbData	dev_prop;
	dev_prop.push_back(Tango::DbDatum("AutoROIEnabled"));
	dev_prop.push_back(Tango::DbDatum("AutoROIMagnificationFactorX"));
	dev_prop.push_back(Tango::DbDatum("AutoROIMagnificationFactorY"));
	dev_prop.push_back(Tango::DbDatum("PixelSizeX"));
	dev_prop.push_back(Tango::DbDatum("PixelSizeY"));
	dev_prop.push_back(Tango::DbDatum("OpticalMagnification"));
	dev_prop.push_back(Tango::DbDatum("FitNbIterationsMax"));
	dev_prop.push_back(Tango::DbDatum("FitTolerance"));
	dev_prop.push_back(Tango::DbDatum("MemorizedOperationType"));
	dev_prop.push_back(Tango::DbDatum("MemorizedOperationLevel"));
	dev_prop.push_back(Tango::DbDatum("XProjEnabled"));
	dev_prop.push_back(Tango::DbDatum("YProjEnabled"));

	//	Call database and extract values
	//--------------------------------------------
	if (Tango::Util::instance()->_UseDb==true)
		get_db_device()->get_property(dev_prop);
	Tango::DbDatum	def_prop, cl_prop;
	FitGaussianClass	*ds_class =
		(static_cast<FitGaussianClass *>(get_device_class()));
	int	i = -1;

	//	Try to initialize AutoROIEnabled from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  autoROIEnabled;
	else {
		//	Try to initialize AutoROIEnabled from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  autoROIEnabled;
	}
	//	And try to extract AutoROIEnabled value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  autoROIEnabled;

	//	Try to initialize AutoROIMagnificationFactorX from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  autoROIMagnificationFactorX;
	else {
		//	Try to initialize AutoROIMagnificationFactorX from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  autoROIMagnificationFactorX;
	}
	//	And try to extract AutoROIMagnificationFactorX value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  autoROIMagnificationFactorX;

	//	Try to initialize AutoROIMagnificationFactorY from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  autoROIMagnificationFactorY;
	else {
		//	Try to initialize AutoROIMagnificationFactorY from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  autoROIMagnificationFactorY;
	}
	//	And try to extract AutoROIMagnificationFactorY value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  autoROIMagnificationFactorY;

	//	Try to initialize PixelSizeX from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  pixelSizeX;
	else {
		//	Try to initialize PixelSizeX from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  pixelSizeX;
	}
	//	And try to extract PixelSizeX value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  pixelSizeX;

	//	Try to initialize PixelSizeY from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  pixelSizeY;
	else {
		//	Try to initialize PixelSizeY from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  pixelSizeY;
	}
	//	And try to extract PixelSizeY value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  pixelSizeY;

	//	Try to initialize OpticalMagnification from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  opticalMagnification;
	else {
		//	Try to initialize OpticalMagnification from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  opticalMagnification;
	}
	//	And try to extract OpticalMagnification value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  opticalMagnification;

	//	Try to initialize FitNbIterationsMax from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  fitNbIterationsMax;
	else {
		//	Try to initialize FitNbIterationsMax from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  fitNbIterationsMax;
	}
	//	And try to extract FitNbIterationsMax value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  fitNbIterationsMax;

	//	Try to initialize FitTolerance from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  fitTolerance;
	else {
		//	Try to initialize FitTolerance from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  fitTolerance;
	}
	//	And try to extract FitTolerance value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  fitTolerance;

	//	Try to initialize MemorizedOperationType from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  memorizedOperationType;
	else {
		//	Try to initialize MemorizedOperationType from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  memorizedOperationType;
	}
	//	And try to extract MemorizedOperationType value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  memorizedOperationType;

	//	Try to initialize MemorizedOperationLevel from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  memorizedOperationLevel;
	else {
		//	Try to initialize MemorizedOperationLevel from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  memorizedOperationLevel;
	}
	//	And try to extract MemorizedOperationLevel value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  memorizedOperationLevel;

	//	Try to initialize XProjEnabled from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  xProjEnabled;
	else {
		//	Try to initialize XProjEnabled from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  xProjEnabled;
	}
	//	And try to extract XProjEnabled value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  xProjEnabled;

	//	Try to initialize YProjEnabled from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  yProjEnabled;
	else {
		//	Try to initialize YProjEnabled from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  yProjEnabled;
	}
	//	And try to extract YProjEnabled value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  yProjEnabled;



	//	End of Automatic code generation
	//------------------------------------------------------------------
	yat4tango::PropertyHelper::create_property_if_empty(this, dev_prop, "false", 	"AutoROIEnabled");	
	yat4tango::PropertyHelper::create_property_if_empty(this, dev_prop, "5.0", 		"AutoROIMagnificationFactorX");	
	yat4tango::PropertyHelper::create_property_if_empty(this, dev_prop, "1.5", 		"AutoROIMagnificationFactorY");	
	yat4tango::PropertyHelper::create_property_if_empty(this, dev_prop, "5.86", 	"PixelSizeX");	
	yat4tango::PropertyHelper::create_property_if_empty(this, dev_prop, "5.86", 	"PixelSizeY");	
	yat4tango::PropertyHelper::create_property_if_empty(this, dev_prop, "2.55", 	"OpticalMagnification");	
	yat4tango::PropertyHelper::create_property_if_empty(this, dev_prop, "256", 		"FitNbIterationsMax");	
	yat4tango::PropertyHelper::create_property_if_empty(this, dev_prop, "1.e-6", 	"FitTolerance");	
	yat4tango::PropertyHelper::create_property_if_empty(this, dev_prop, "NONE", 	"MemorizedOperationType");
	yat4tango::PropertyHelper::create_property_if_empty(this, dev_prop, "0", 		"MemorizedOperationLevel");	
	yat4tango::PropertyHelper::create_property_if_empty(this, dev_prop, "true", 	"XProjEnabled");
	yat4tango::PropertyHelper::create_property_if_empty(this, dev_prop, "true", 	"YProjEnabled");	

}
//+----------------------------------------------------------------------------
//
// method : 		FitGaussian::always_executed_hook()
// 
// description : 	method always executed before any command is executed
//
//-----------------------------------------------------------------------------
void FitGaussian::always_executed_hook()
{
    yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());
    try
    {        
        if(!m_is_device_initialized)//nothing to do ! device need init
            return;

        //- get the singleton control objet used to pilot the lima framework
        m_ct = ControlFactory::instance().get_control("FitGaussian");

        dev_state();
    }
    catch (Exception& e)
    {
        ERROR_STREAM << e.getErrMsg() << endl;
        m_status_message << "Initialization Failed : " << e.getErrMsg() << endl;
        //- throw exception
        set_state(Tango::FAULT);
        m_is_device_initialized = false;
        return;
    }
    catch (Tango::DevFailed& df)
    {
        ERROR_STREAM << df << endl;
        INFO_STREAM << "Initialization Failed : " << std::string(df.errors[0].desc) << endl;
        m_status_message << "Initialization Failed : " << std::string(df.errors[0].desc) << endl;
        m_is_device_initialized = false;
        set_state(Tango::FAULT);
	}
      	
}
//+----------------------------------------------------------------------------
//
// method : 		FitGaussian::read_attr_hardware
// 
// description : 	Hardware acquisition for attributes.
//
//-----------------------------------------------------------------------------
void FitGaussian::read_attr_hardware(vector<long> &attr_list)
{
	DEBUG_STREAM << "FitGaussian::read_attr_hardware(vector<long> &attr_list) entering... "<< endl;
	//	Add your own code here
}

//+----------------------------------------------------------------------------
//
// method : 		FitGaussian::read_myPushTime
// 
// description : 	Extract real attribute values for myPushTime acquisition result.
//
//-----------------------------------------------------------------------------
void FitGaussian::read_myPushTime(Tango::Attribute &attr)
{
	DEBUG_STREAM << "FitGaussian::read_myPushTime(Tango::Attribute &attr) entering... "<< endl;
	yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());	
	try
	{
		strcpy(*attr_myPushTime_read,  m_fit_task->get_time_ns_to_str().c_str());
		attr.set_value(attr_myPushTime_read);
	}
	catch(Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		Tango::Except::re_throw_exception(df,
										"TANGO_DEVICE_ERROR",
										string(df.errors[0].desc).c_str(),
										"FitGaussian::read_myPushTime()");
	}	
}

//+----------------------------------------------------------------------------
//
// method : 		FitGaussian::read_AutoROIEnabled
// 
// description : 	Extract real attribute values for AutoROIEnabled acquisition result.
//
//-----------------------------------------------------------------------------
void FitGaussian::read_AutoROIEnabled(Tango::Attribute &attr)
{
	DEBUG_STREAM << "FitGaussian::read_AutoROIEnabled(Tango::Attribute &attr) entering... "<< endl;
}

//+----------------------------------------------------------------------------
//
// method : 		FitGaussian::write_AutoROIEnabled
// 
// description : 	Write AutoROIEnabled attribute values to hardware.
//
//-----------------------------------------------------------------------------
void FitGaussian::write_AutoROIEnabled(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "FitGaussian::write_AutoROIEnabled(Tango::WAttribute &attr) entering... "<< endl;
	yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());
	try
	{
		attr.get_write_value(attr_AutoROIEnabled_write);
		if(m_fit_task)
		{
			m_fit_task->set_auto_roi_enabled(attr_AutoROIEnabled_write);
			yat4tango::PropertyHelper::set_property(this, "AutoROIEnabled", attr_AutoROIEnabled_write);
		}
	}
	catch (Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		Tango::Except::re_throw_exception(df,
										  "TANGO_DEVICE_ERROR",
										  std::string(df.errors[0].desc).c_str(),
										  "FitGaussian::write_AutoROIEnabled");
	}	
}

//+----------------------------------------------------------------------------
//
// method : 		FitGaussian::read_AutoROIFound
// 
// description : 	Extract real attribute values for AutoROIFound acquisition result.
//
//-----------------------------------------------------------------------------
void FitGaussian::read_AutoROIFound(Tango::Attribute &attr)
{
	DEBUG_STREAM << "FitGaussian::read_AutoROIFound(Tango::Attribute &attr) entering... "<< endl;
	yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());	
	try
	{
		if(m_fit_task)
		{
			if(std::isnan(m_fit_task->get_param("AutoROIConverged")))
			{
				*attr_AutoROIFound_read = false;
				attr.set_value(attr_AutoROIFound_read);
				attr.set_quality(Tango::ATTR_ALARM);				
			}
			else
			{
				*attr_AutoROIFound_read = (Tango::DevBoolean)(m_fit_task->get_param("AutoROIConverged"));
				attr.set_value(attr_AutoROIFound_read);
				attr.set_quality(Tango::ATTR_VALID);
			}
		}
	}
	catch(Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		Tango::Except::re_throw_exception(df,
										"TANGO_DEVICE_ERROR",
										string(df.errors[0].desc).c_str(),
										"FitGaussian::read_XProjFitConverged()");
	}		
}

//+----------------------------------------------------------------------------
//
// method : 		FitGaussian::read_AutoROIOriginX
// 
// description : 	Extract real attribute values for AutoROIOriginX acquisition result.
//
//-----------------------------------------------------------------------------
void FitGaussian::read_AutoROIOriginX(Tango::Attribute &attr)
{
	DEBUG_STREAM << "FitGaussian::read_AutoROIOriginX(Tango::Attribute &attr) entering... "<< endl;
	try
	{
		if(m_fit_task)
		{
			if(std::isnan(m_fit_task->get_param("AutoROIOriginX")))
			{
				*attr_AutoROIOriginX_read = 0;
				attr.set_value(attr_AutoROIOriginX_read);
				attr.set_quality(Tango::ATTR_ALARM);
			}
			else
			{
				*attr_AutoROIOriginX_read = (Tango::DevLong)(m_fit_task->get_param("AutoROIOriginX"));
				attr.set_value(attr_AutoROIOriginX_read);
				attr.set_quality(Tango::ATTR_VALID);				
			}
		}
	}
	catch(Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		Tango::Except::re_throw_exception(df,
										"TANGO_DEVICE_ERROR",
										string(df.errors[0].desc).c_str(),
										"FitGaussian::read_AutoROIOriginX()");
	}		
}

//+----------------------------------------------------------------------------
//
// method : 		FitGaussian::read_AutoROIOriginY
// 
// description : 	Extract real attribute values for AutoROIOriginY acquisition result.
//
//-----------------------------------------------------------------------------
void FitGaussian::read_AutoROIOriginY(Tango::Attribute &attr)
{
	DEBUG_STREAM << "FitGaussian::read_AutoROIOriginY(Tango::Attribute &attr) entering... "<< endl;
	try
	{
		if(m_fit_task)
		{
			if(std::isnan(m_fit_task->get_param("AutoROIOriginY")))
			{
				*attr_AutoROIOriginY_read = 0;
				attr.set_value(attr_AutoROIOriginY_read);
				attr.set_quality(Tango::ATTR_ALARM);
			}
			else
			{				
				*attr_AutoROIOriginY_read = (Tango::DevLong)(m_fit_task->get_param("AutoROIOriginY"));
				attr.set_value(attr_AutoROIOriginY_read);
				attr.set_quality(Tango::ATTR_VALID);
			}			
		}
	}
	catch(Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		Tango::Except::re_throw_exception(df,
										"TANGO_DEVICE_ERROR",
										string(df.errors[0].desc).c_str(),
										"FitGaussian::read_AutoROIOriginY()");
	}
}

//+----------------------------------------------------------------------------
//
// method : 		FitGaussian::read_AutoROIWidth
// 
// description : 	Extract real attribute values for AutoROIWidth acquisition result.
//
//-----------------------------------------------------------------------------
void FitGaussian::read_AutoROIWidth(Tango::Attribute &attr)
{
	DEBUG_STREAM << "FitGaussian::read_AutoROIWidth(Tango::Attribute &attr) entering... "<< endl;
	try
	{
		if(m_fit_task)
		{
			if(std::isnan(m_fit_task->get_param("AutoROIWidth")))
			{
				*attr_AutoROIWidth_read = 0;
				attr.set_value(attr_AutoROIWidth_read);
				attr.set_quality(Tango::ATTR_ALARM);
			}
			else
			{
				*attr_AutoROIWidth_read = (Tango::DevLong)(m_fit_task->get_param("AutoROIWidth"));
				attr.set_value(attr_AutoROIWidth_read);
				attr.set_quality(Tango::ATTR_VALID);
			}			
		}
	}
	catch(Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		Tango::Except::re_throw_exception(df,
										"TANGO_DEVICE_ERROR",
										string(df.errors[0].desc).c_str(),
										"FitGaussian::read_AutoROIWidth()");
	}		
}

//+----------------------------------------------------------------------------
//
// method : 		FitGaussian::read_AutoROIHeight
// 
// description : 	Extract real attribute values for AutoROIHeight acquisition result.
//
//-----------------------------------------------------------------------------
void FitGaussian::read_AutoROIHeight(Tango::Attribute &attr)
{
	DEBUG_STREAM << "FitGaussian::read_AutoROIHeight(Tango::Attribute &attr) entering... "<< endl;
	try
	{
		if(m_fit_task)
		{
			if(std::isnan(m_fit_task->get_param("AutoROIHeight")))
			{
				*attr_AutoROIHeight_read = 0;
				attr.set_value(attr_AutoROIHeight_read);
				attr.set_quality(Tango::ATTR_ALARM);
			}
			else
			{
				*attr_AutoROIHeight_read = (Tango::DevLong)(m_fit_task->get_param("AutoROIHeight"));
				attr.set_value(attr_AutoROIHeight_read);
				attr.set_quality(Tango::ATTR_VALID);
			}			
		}
	}
	catch(Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		Tango::Except::re_throw_exception(df,
										"TANGO_DEVICE_ERROR",
										string(df.errors[0].desc).c_str(),
										"FitGaussian::read_AutoROIHeight()");
	}
}


//+----------------------------------------------------------------------------
//
// method : 		FitGaussian::read_operationType
// 
// description : 	Extract real attribute values for operationType acquisition result.
//
//-----------------------------------------------------------------------------
void FitGaussian::read_operationType(Tango::Attribute &attr)
{
	DEBUG_STREAM << "FitGaussian::read_operationType(Tango::Attribute &attr) entering... "<< endl;
	yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());	
	try
	{
		strcpy(*attr_operationType_read, m_operation_type.c_str());
		attr.set_value(attr_operationType_read);
	}
	catch(Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		Tango::Except::re_throw_exception(df,
										"TANGO_DEVICE_ERROR",
										string(df.errors[0].desc).c_str(),
										"FitGaussian::read_operationType()");
	}		
}

//+----------------------------------------------------------------------------
//
// method : 		FitGaussian::read_operationList
// 
// description : 	Extract real attribute values for operationList acquisition result.
//
//-----------------------------------------------------------------------------
void FitGaussian::read_operationList(Tango::Attribute &attr)
{
	DEBUG_STREAM << "FitGaussian::read_operationList(Tango::Attribute &attr) entering... "<< endl;
	yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());
    Tango::DevString *ptr = new Tango::DevString[ 1024 ];

    int item_idx = 0;
	ptr[item_idx] = CORBA::string_dup("");
    for (std::map<long, operationParams >::iterator itMap = m_map_operations.begin(); itMap != m_map_operations.end(); ++itMap)
    {
		if(itMap->second.operationType != "NONE")
		{
			std::stringstream item("");
			item << "runLevel = " << itMap->first
			<< " : "
			<< "Operation = " << itMap->second.operationType
			<< " ( "<< itMap->second.operationValue<<" )";
			ptr[item_idx] = CORBA::string_dup((item.str()).c_str());
			item_idx++;
		}
    }
	
    attr.set_value(ptr, item_idx, 0, true);	
}

//+----------------------------------------------------------------------------
//
// method : 		FitGaussian::read_version
// 
// description : 	Extract real attribute values for version acquisition result.
//
//-----------------------------------------------------------------------------
void FitGaussian::read_version(Tango::Attribute &attr)
{
	DEBUG_STREAM << "FitGaussian::read_version(Tango::Attribute &attr) entering... "<< endl;
	yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());	
	try
	{
		strcpy(*attr_version_read, CURRENT_VERSION);
		attr.set_value(attr_version_read);
	}
	catch(Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		Tango::Except::re_throw_exception(df,
										"TANGO_DEVICE_ERROR",
										string(df.errors[0].desc).c_str(),
										"FitGaussian::read_version()");
	}		
}

//+----------------------------------------------------------------------------
//
// method : 		FitGaussian::read_XProjEnabled
// 
// description : 	Extract real attribute values for XProjEnabled acquisition result.
//
//-----------------------------------------------------------------------------
void FitGaussian::read_XProjEnabled(Tango::Attribute &attr)
{
	DEBUG_STREAM << "FitGaussian::read_XProjEnabled(Tango::Attribute &attr) entering... "<< endl;
}

//+----------------------------------------------------------------------------
//
// method : 		FitGaussian::write_XProjEnabled
// 
// description : 	Write XProjEnabled attribute values to hardware.
//
//-----------------------------------------------------------------------------
void FitGaussian::write_XProjEnabled(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "FitGaussian::write_XProjEnabled(Tango::WAttribute &attr) entering... "<< endl;
	yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());
	try
	{
		attr.get_write_value(attr_XProjEnabled_write);
		if(m_fit_task)
		{
			m_fit_task->set_proj_enabled(attr_XProjEnabled_write, true);
			yat4tango::PropertyHelper::set_property(this, "XProjEnabled", attr_XProjEnabled_write);
		}
	}
	catch (Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		Tango::Except::re_throw_exception(df,
										  "TANGO_DEVICE_ERROR",
										  std::string(df.errors[0].desc).c_str(),
										  "FitGaussian::write_XProjEnabled");
	}	
}

//+----------------------------------------------------------------------------
//
// method : 		FitGaussian::read_XProjFitConverged
// 
// description : 	Extract real attribute values for XProjFitConverged acquisition result.
//
//-----------------------------------------------------------------------------
void FitGaussian::read_XProjFitConverged(Tango::Attribute &attr)
{
	DEBUG_STREAM << "FitGaussian::read_XProjFitConverged(Tango::Attribute &attr) entering... "<< endl;
	yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());	
	try
	{
		if(m_fit_task)
		{
			if(std::isnan(m_fit_task->get_param("XProjFitConverged")))
			{
				*attr_XProjFitConverged_read = false;
				attr.set_value(attr_XProjFitConverged_read);
				attr.set_quality(Tango::ATTR_ALARM);
			}
			else
			{
				*attr_XProjFitConverged_read = (Tango::DevBoolean)(m_fit_task->get_param("XProjFitConverged"));
				attr.set_value(attr_XProjFitConverged_read);
				attr.set_quality(Tango::ATTR_VALID);
			}			
		}
	}
	catch(Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		Tango::Except::re_throw_exception(df,
										"TANGO_DEVICE_ERROR",
										string(df.errors[0].desc).c_str(),
										"FitGaussian::read_XProjFitConverged()");
	}		
}

//+----------------------------------------------------------------------------
//
// method : 		FitGaussian::read_XProjFitCenter
// 
// description : 	Extract real attribute values for XProjFitCenter acquisition result.
//
//-----------------------------------------------------------------------------
void FitGaussian::read_XProjFitCenter(Tango::Attribute &attr)
{
	DEBUG_STREAM << "FitGaussian::read_XProjFitCenter(Tango::Attribute &attr) entering... "<< endl;
	yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());	
	try
	{
		if(m_fit_task)
		{
			if(std::isnan(m_fit_task->get_param("XProjFitCenter")))
			{
				*attr_XProjFitCenter_read = std::nan("");
				attr.set_value(attr_XProjFitCenter_read);
				attr.set_quality(Tango::ATTR_ALARM);
			}
			else
			{
				*attr_XProjFitCenter_read = m_fit_task->get_param("XProjFitCenter");
				attr.set_value(attr_XProjFitCenter_read);
				attr.set_quality(Tango::ATTR_VALID);
			}
		}
	}
	catch(Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		Tango::Except::re_throw_exception(df,
										"TANGO_DEVICE_ERROR",
										string(df.errors[0].desc).c_str(),
										"FitGaussian::read_XProjFitCenter()");
	}		
}

//+----------------------------------------------------------------------------
//
// method : 		FitGaussian::read_XProjFitMag
// 
// description : 	Extract real attribute values for XProjFitMag acquisition result.
//
//-----------------------------------------------------------------------------
void FitGaussian::read_XProjFitMag(Tango::Attribute &attr)
{
	DEBUG_STREAM << "FitGaussian::read_XProjFitMag(Tango::Attribute &attr) entering... "<< endl;
	yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());	
	try
	{
		if(m_fit_task)
		{
			if(std::isnan(m_fit_task->get_param("XProjFitMag")))
			{
				*attr_XProjFitMag_read = std::nan("");
				attr.set_value(attr_XProjFitMag_read);
				attr.set_quality(Tango::ATTR_ALARM);
			}
			else
			{
				*attr_XProjFitMag_read = m_fit_task->get_param("XProjFitMag");
				attr.set_value(attr_XProjFitMag_read);
				attr.set_quality(Tango::ATTR_VALID);
			}
		}
	}
	catch(Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		Tango::Except::re_throw_exception(df,
										"TANGO_DEVICE_ERROR",
										string(df.errors[0].desc).c_str(),
										"FitGaussian::read_XProjFitMag()");
	}		
}

//+----------------------------------------------------------------------------
//
// method : 		FitGaussian::read_XProjFitSigma
// 
// description : 	Extract real attribute values for XProjFitSigma acquisition result.
//
//-----------------------------------------------------------------------------
void FitGaussian::read_XProjFitSigma(Tango::Attribute &attr)
{
	DEBUG_STREAM << "FitGaussian::read_XProjFitSigma(Tango::Attribute &attr) entering... "<< endl;
	yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());	
	try
	{
		if(m_fit_task)
		{
			if(std::isnan(m_fit_task->get_param("XProjFitSigma")))
			{
				*attr_XProjFitSigma_read = std::nan("");
				attr.set_value(attr_XProjFitSigma_read);
				attr.set_quality(Tango::ATTR_ALARM);
			}
			else
			{
				*attr_XProjFitSigma_read = m_fit_task->get_param("XProjFitSigma");
				attr.set_value(attr_XProjFitSigma_read);
				attr.set_quality(Tango::ATTR_VALID);
			}			
		}
	}
	catch(Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		Tango::Except::re_throw_exception(df,
										"TANGO_DEVICE_ERROR",
										string(df.errors[0].desc).c_str(),
										"FitGaussian::read_XProjFitSigma()");
	}		
}

//+----------------------------------------------------------------------------
//
// method : 		FitGaussian::read_XProjFitFWHM
// 
// description : 	Extract real attribute values for XProjFitFWHM acquisition result.
//
//-----------------------------------------------------------------------------
void FitGaussian::read_XProjFitFWHM(Tango::Attribute &attr)
{
	DEBUG_STREAM << "FitGaussian::read_XProjFitFWHM(Tango::Attribute &attr) entering... "<< endl;
	yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());	
	try
	{
		if(m_fit_task)
		{
			if(std::isnan(m_fit_task->get_param("XProjFitFWHM")))
			{
				*attr_XProjFitFWHM_read = std::nan("");
				attr.set_value(attr_XProjFitFWHM_read);
				attr.set_quality(Tango::ATTR_ALARM);
			}
			else
			{
				*attr_XProjFitFWHM_read = m_fit_task->get_param("XProjFitFWHM");
				attr.set_value(attr_XProjFitFWHM_read);
				attr.set_quality(Tango::ATTR_VALID);
			}			
		}
	}
	catch(Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		Tango::Except::re_throw_exception(df,
										"TANGO_DEVICE_ERROR",
										string(df.errors[0].desc).c_str(),
										"FitGaussian::read_XProjFitFWHM()");
	}		
}

//+----------------------------------------------------------------------------
//
// method : 		FitGaussian::read_XProjFitBG
// 
// description : 	Extract real attribute values for XProjFitBG acquisition result.
//
//-----------------------------------------------------------------------------
void FitGaussian::read_XProjFitBG(Tango::Attribute &attr)
{
	DEBUG_STREAM << "FitGaussian::read_XProjFitBG(Tango::Attribute &attr) entering... "<< endl;
	yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());	
	try
	{
		if(m_fit_task)
		{
			if(std::isnan(m_fit_task->get_param("XProjFitBG")))
			{
				*attr_XProjFitBG_read = std::nan("");
				attr.set_value(attr_XProjFitBG_read);
				attr.set_quality(Tango::ATTR_ALARM);
			}
			else
			{
				*attr_XProjFitBG_read = m_fit_task->get_param("XProjFitBG");
				attr.set_value(attr_XProjFitBG_read);
				attr.set_quality(Tango::ATTR_VALID);
			}			
		}
	}
	catch(Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		Tango::Except::re_throw_exception(df,
										"TANGO_DEVICE_ERROR",
										string(df.errors[0].desc).c_str(),
										"FitGaussian::read_XProjFitBG()");
	}		
}


//+----------------------------------------------------------------------------
//
// method : 		FitGaussian::read_XProjFitChi2
// 
// description : 	Extract real attribute values for XProjFitChi2 acquisition result.
//
//-----------------------------------------------------------------------------
void FitGaussian::read_XProjFitChi2(Tango::Attribute &attr)
{
	DEBUG_STREAM << "FitGaussian::read_XProjFitChi2(Tango::Attribute &attr) entering... "<< endl;
	yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());	
	try
	{
		if(m_fit_task)
		{
			if(std::isnan(m_fit_task->get_param("XProjFitChi2")))
			{
				*attr_XProjFitChi2_read = std::nan("");
				attr.set_value(attr_XProjFitChi2_read);
				attr.set_quality(Tango::ATTR_ALARM);
			}
			else
			{
				*attr_XProjFitChi2_read = m_fit_task->get_param("XProjFitChi2");
				attr.set_value(attr_XProjFitChi2_read);
				attr.set_quality(Tango::ATTR_VALID);
			}			
		}
	}
	catch(Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		Tango::Except::re_throw_exception(df,
										"TANGO_DEVICE_ERROR",
										string(df.errors[0].desc).c_str(),
										"FitGaussian::read_XProjFitChi2()");
	}
}

//+----------------------------------------------------------------------------
//
// method : 		FitGaussian::read_XProj
// 
// description : 	Extract real attribute values for XProj acquisition result.
//
//-----------------------------------------------------------------------------
void FitGaussian::read_XProj(Tango::Attribute &attr)
{
	DEBUG_STREAM << "FitGaussian::read_XProj(Tango::Attribute &attr) entering... "<< endl;
	yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());	
	try
	{
		if(m_fit_task)
		{
			attr.set_value(const_cast<Tango::DevDouble*>(&m_fit_task->get_spectrum("XProj").at(0)), m_fit_task->get_spectrum("XProj").size());
		}
	}
	catch(Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		Tango::Except::re_throw_exception(df,
										"TANGO_DEVICE_ERROR",
										string(df.errors[0].desc).c_str(),
										"FitGaussian::read_XProj()");
	}	
}

//+----------------------------------------------------------------------------
//
// method : 		FitGaussian::read_XProjFitted
// 
// description : 	Extract real attribute values for XProjFitted acquisition result.
//
//-----------------------------------------------------------------------------
void FitGaussian::read_XProjFitted(Tango::Attribute &attr)
{
	DEBUG_STREAM << "FitGaussian::read_XProjFitted(Tango::Attribute &attr) entering... "<< endl;
	yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());	
	try
	{
		if(m_fit_task)
		{
			attr.set_value(const_cast<Tango::DevDouble*>(&m_fit_task->get_spectrum("XProjFitted").at(0)), m_fit_task->get_spectrum("XProjFitted").size());
		}
	}
	catch(Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		Tango::Except::re_throw_exception(df,
										"TANGO_DEVICE_ERROR",
										string(df.errors[0].desc).c_str(),
										"FitGaussian::read_XProjFitted()");
	}
}


//+----------------------------------------------------------------------------
//
// method : 		FitGaussian::read_YProjEnabled
// 
// description : 	Extract real attribute values for YProjEnabled acquisition result.
//
//-----------------------------------------------------------------------------
void FitGaussian::read_YProjEnabled(Tango::Attribute &attr)
{
	DEBUG_STREAM << "FitGaussian::read_YProjEnabled(Tango::Attribute &attr) entering... "<< endl;
}


//+----------------------------------------------------------------------------
//
// method : 		FitGaussian::write_YProjEnabled
// 
// description : 	Write YProjEnabled attribute values to hardware.
//
//-----------------------------------------------------------------------------
void FitGaussian::write_YProjEnabled(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "FitGaussian::write_YProjEnabled(Tango::WAttribute &attr) entering... "<< endl;
	yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());
	try
	{
		attr.get_write_value(attr_YProjEnabled_write);
		if(m_fit_task)
		{
			m_fit_task->set_proj_enabled(attr_YProjEnabled_write, false);
			yat4tango::PropertyHelper::set_property(this, "YProjEnabled", attr_YProjEnabled_write);
		}
	}
	catch (Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		Tango::Except::re_throw_exception(df,
										  "TANGO_DEVICE_ERROR",
										  std::string(df.errors[0].desc).c_str(),
										  "FitGaussian::write_YProjEnabled");
	}
}

//+----------------------------------------------------------------------------
//
// method : 		FitGaussian::read_YProjFitConverged
// 
// description : 	Extract real attribute values for YProjFitConverged acquisition result.
//
//-----------------------------------------------------------------------------
void FitGaussian::read_YProjFitConverged(Tango::Attribute &attr)
{
	DEBUG_STREAM << "FitGaussian::read_YProjFitConverged(Tango::Attribute &attr) entering... "<< endl;
	yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());	
	try
	{
		if(m_fit_task)
		{
			if(std::isnan(m_fit_task->get_param("YProjFitConverged")))
			{
				*attr_YProjFitConverged_read = false;
				attr.set_value(attr_YProjFitConverged_read);
				attr.set_quality(Tango::ATTR_ALARM);
			}
			else
			{
				*attr_YProjFitConverged_read = (Tango::DevBoolean)(m_fit_task->get_param("YProjFitConverged"));
				attr.set_value(attr_YProjFitConverged_read);
				attr.set_quality(Tango::ATTR_VALID);
			}
		}
	}
	catch(Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		Tango::Except::re_throw_exception(df,
										"TANGO_DEVICE_ERROR",
										string(df.errors[0].desc).c_str(),
										"FitGaussian::read_YProjFitConverged()");
	}		
}


//+----------------------------------------------------------------------------
//
// method : 		FitGaussian::read_YProjFitCenter
// 
// description : 	Extract real attribute values for YProjFitCenter acquisition result.
//
//-----------------------------------------------------------------------------
void FitGaussian::read_YProjFitCenter(Tango::Attribute &attr)
{
	DEBUG_STREAM << "FitGaussian::read_YProjFitCenter(Tango::Attribute &attr) entering... "<< endl;
	yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());	
	try
	{
		if(m_fit_task)
		{
			if(std::isnan(m_fit_task->get_param("YProjFitCenter")))
			{
				*attr_YProjFitCenter_read = std::nan("");
				attr.set_value(attr_YProjFitCenter_read);
				attr.set_quality(Tango::ATTR_ALARM);
			}
			else
			{
				*attr_YProjFitCenter_read = m_fit_task->get_param("YProjFitCenter");
				attr.set_value(attr_YProjFitCenter_read);
				attr.set_quality(Tango::ATTR_VALID);
			}
		}
	}
	catch(Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		Tango::Except::re_throw_exception(df,
										"TANGO_DEVICE_ERROR",
										string(df.errors[0].desc).c_str(),
										"FitGaussian::read_YProjFitCenter()");
	}
}

//+----------------------------------------------------------------------------
//
// method : 		FitGaussian::read_YProjFitMag
// 
// description : 	Extract real attribute values for YProjFitMag acquisition result.
//
//-----------------------------------------------------------------------------
void FitGaussian::read_YProjFitMag(Tango::Attribute &attr)
{
	DEBUG_STREAM << "FitGaussian::read_YProjFitMag(Tango::Attribute &attr) entering... "<< endl;
	yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());	
	try
	{
		if(m_fit_task)
		{
			if(std::isnan(m_fit_task->get_param("YProjFitMag")))
			{
				*attr_YProjFitMag_read = std::nan("");
				attr.set_value(attr_YProjFitMag_read);
				attr.set_quality(Tango::ATTR_ALARM);
			}
			else
			{
				*attr_YProjFitMag_read = m_fit_task->get_param("YProjFitMag");
				attr.set_value(attr_YProjFitMag_read);
				attr.set_quality(Tango::ATTR_VALID);
			}
		}
	}
	catch(Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		Tango::Except::re_throw_exception(df,
										"TANGO_DEVICE_ERROR",
										string(df.errors[0].desc).c_str(),
										"FitGaussian::read_YProjFitMag()");
	}	
}

//+----------------------------------------------------------------------------
//
// method : 		FitGaussian::read_YProjFitSigma
// 
// description : 	Extract real attribute values for YProjFitSigma acquisition result.
//
//-----------------------------------------------------------------------------
void FitGaussian::read_YProjFitSigma(Tango::Attribute &attr)
{
	DEBUG_STREAM << "FitGaussian::read_YProjFitSigma(Tango::Attribute &attr) entering... "<< endl;
	yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());	
	try
	{
		if(m_fit_task)
		{
			if(std::isnan(m_fit_task->get_param("YProjFitSigma")))
			{
				*attr_YProjFitSigma_read = std::nan("");
				attr.set_value(attr_YProjFitSigma_read);
				attr.set_quality(Tango::ATTR_ALARM);
			}
			else
			{
				*attr_YProjFitSigma_read = m_fit_task->get_param("YProjFitSigma");
				attr.set_value(attr_YProjFitSigma_read);
				attr.set_quality(Tango::ATTR_VALID);
			}
		}
	}
	catch(Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		Tango::Except::re_throw_exception(df,
										"TANGO_DEVICE_ERROR",
										string(df.errors[0].desc).c_str(),
										"FitGaussian::read_YProjFitSigma()");
	}		
}

//+----------------------------------------------------------------------------
//
// method : 		FitGaussian::read_YProjFitFWHM
// 
// description : 	Extract real attribute values for YProjFitFWHM acquisition result.
//
//-----------------------------------------------------------------------------
void FitGaussian::read_YProjFitFWHM(Tango::Attribute &attr)
{
	DEBUG_STREAM << "FitGaussian::read_YProjFitFWHM(Tango::Attribute &attr) entering... "<< endl;
	yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());	
	try
	{
		if(m_fit_task)
		{
			if(std::isnan(m_fit_task->get_param("YProjFitFWHM")))
			{
				*attr_YProjFitFWHM_read = std::nan("");
				attr.set_value(attr_YProjFitFWHM_read);
				attr.set_quality(Tango::ATTR_ALARM);
			}
			else
			{
				*attr_YProjFitFWHM_read = m_fit_task->get_param("YProjFitFWHM");
				attr.set_value(attr_YProjFitFWHM_read);
				attr.set_quality(Tango::ATTR_VALID);
			}			
		}
	}
	catch(Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		Tango::Except::re_throw_exception(df,
										"TANGO_DEVICE_ERROR",
										string(df.errors[0].desc).c_str(),
										"FitGaussian::read_YProjFitFWHM()");
	}		
}

//+----------------------------------------------------------------------------
//
// method : 		FitGaussian::read_YProjFitBG
// 
// description : 	Extract real attribute values for YProjFitBG acquisition result.
//
//-----------------------------------------------------------------------------
void FitGaussian::read_YProjFitBG(Tango::Attribute &attr)
{
	DEBUG_STREAM << "FitGaussian::read_YProjFitBG(Tango::Attribute &attr) entering... "<< endl;
	yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());	
	try
	{
		if(m_fit_task)
		{
			if(std::isnan(m_fit_task->get_param("YProjFitBG")))
			{
				*attr_YProjFitBG_read = std::nan("");
				attr.set_value(attr_YProjFitBG_read);
				attr.set_quality(Tango::ATTR_ALARM);
			}
			else
			{
				*attr_YProjFitBG_read = m_fit_task->get_param("YProjFitBG");
				attr.set_value(attr_YProjFitBG_read);
				attr.set_quality(Tango::ATTR_VALID);
			}			
		}
	}
	catch(Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		Tango::Except::re_throw_exception(df,
										"TANGO_DEVICE_ERROR",
										string(df.errors[0].desc).c_str(),
										"FitGaussian::read_YProjFitBG()");
	}		
}

//+----------------------------------------------------------------------------
//
// method : 		FitGaussian::read_YProjFitChi2
// 
// description : 	Extract real attribute values for YProjFitChi2 acquisition result.
//
//-----------------------------------------------------------------------------
void FitGaussian::read_YProjFitChi2(Tango::Attribute &attr)
{
	DEBUG_STREAM << "FitGaussian::read_YProjFitChi2(Tango::Attribute &attr) entering... "<< endl;
	yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());	
	try
	{
		if(m_fit_task)
		{
			if(std::isnan(m_fit_task->get_param("YProjFitChi2")))
			{
				*attr_YProjFitChi2_read = std::nan("");
				attr.set_value(attr_YProjFitChi2_read);
				attr.set_quality(Tango::ATTR_ALARM);
			}
			else
			{
				*attr_YProjFitChi2_read = m_fit_task->get_param("YProjFitChi2");
				attr.set_value(attr_YProjFitChi2_read);
				attr.set_quality(Tango::ATTR_VALID);
			}			
		}
	}
	catch(Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		Tango::Except::re_throw_exception(df,
										"TANGO_DEVICE_ERROR",
										string(df.errors[0].desc).c_str(),
										"FitGaussian::read_YProjFitChi2()");
	}	
}

//+----------------------------------------------------------------------------
//
// method : 		FitGaussian::read_YProj
// 
// description : 	Extract real attribute values for YProj acquisition result.
//
//-----------------------------------------------------------------------------
void FitGaussian::read_YProj(Tango::Attribute &attr)
{
	DEBUG_STREAM << "FitGaussian::read_YProj(Tango::Attribute &attr) entering... "<< endl;
	yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());	
	try
	{
		if(m_fit_task)
		{
			attr.set_value(const_cast<Tango::DevDouble*>(&m_fit_task->get_spectrum("YProj").at(0)), m_fit_task->get_spectrum("YProj").size());
		}
	}
	catch(Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		Tango::Except::re_throw_exception(df,
										"TANGO_DEVICE_ERROR",
										string(df.errors[0].desc).c_str(),
										"FitGaussian::read_YProj()");
	}	
}

//+----------------------------------------------------------------------------
//
// method : 		FitGaussian::read_YProjFitted
// 
// description : 	Extract real attribute values for YProjFitted acquisition result.
//
//-----------------------------------------------------------------------------
void FitGaussian::read_YProjFitted(Tango::Attribute &attr)
{
	DEBUG_STREAM << "FitGaussian::read_YProjFitted(Tango::Attribute &attr) entering... "<< endl;
	yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());	
	try
	{
		if(m_fit_task)
		{
			attr.set_value(const_cast<Tango::DevDouble*>(&m_fit_task->get_spectrum("YProjFitted").at(0)), m_fit_task->get_spectrum("YProjFitted").size());
		}
	}
	catch(Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		Tango::Except::re_throw_exception(df,
										"TANGO_DEVICE_ERROR",
										string(df.errors[0].desc).c_str(),
										"FitGaussian::read_YProjFitted()");
	}	
}


//+----------------------------------------------------------------------------
//
// method : 		FitGaussian::read_ROIImage
// 
// description : 	Extract real attribute values for ROIImage acquisition result.
//
//-----------------------------------------------------------------------------
void FitGaussian::read_ROIImage(Tango::Attribute &attr)
{
	DEBUG_STREAM << "FitGaussian::read_ROIImage(Tango::Attribute &attr) entering... "<< endl;
	yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());	
	try
	{
		if(m_fit_task)
		{
			const cv::Mat &img = m_fit_task->get_img_roi();
			if (img.empty())
				std::cout<<"[Error] FitGaussian::read_ROIImage() : get_img_roi() returned an empty image"<<std::endl;
			attr.set_value(reinterpret_cast<Tango::DevUShort*>(img.data),img.cols, img.rows);
		}
	}
	catch(Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		Tango::Except::re_throw_exception(df,
										"TANGO_DEVICE_ERROR",
										string(df.errors[0].desc).c_str(),
										"FitGaussian::read_ROIImage()");
	}

}

//+------------------------------------------------------------------
/**
 *    method:    FitGaussian::delete_external_operation
 *
 */
//+------------------------------------------------------------------

void FitGaussian::delete_external_operation(long level)
{
    DEBUG_STREAM << "FitGaussian::delete_external_operation() entering ... " << endl;
    //free old operation
    yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());
    if (m_ct != 0)
    {
        try
        {			
			std::stringstream opId("");
			opId << m_map_operations[level].opId;
			INFO_STREAM << "\t- delOp [" << opId.str() << "]"<<endl;
			m_ct->externalOperation()->delOp(opId.str());
			m_map_operations.erase(level);
        }
        catch (Exception& e)
        {

            ERROR_STREAM << e.getErrMsg() << endl;
            //- throw exception
            Tango::Except::throw_exception("TANGO_DEVICE_ERROR",
                                           e.getErrMsg().c_str(),
                                           "FitGaussian::delete_external_operation");
        }
    }
}

//+------------------------------------------------------------------
/**
 *    method:    FitGaussian::add_external_operation
 *
 */
//+------------------------------------------------------------------

void FitGaussian::add_external_operation(long level)
{
    DEBUG_STREAM << "FitGaussian::add_external_operation() entering ... " << endl;
    //add a new operation
    yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());
	transform(m_operation_type.begin(), m_operation_type.end(), m_operation_type.begin(), ::toupper);
    if (m_ct != 0)
    {
        try
        {			
            if (m_operation_type == "FIT")
            {
                //create new operation
                std::stringstream opId("");
                SoftOpInstance op;
				opId << level<<":"<<m_operation_type;//<<" ("<<m_operation_value<<")";
				INFO_STREAM << "\t- addOp [" << opId.str() << "]"<<endl;
				operationParams params = {opId.str(), m_operation_type, "0"};
				m_map_operations[level] = params;			
                m_ct->externalOperation()->addOp(USER_LINK_TASK, opId.str(), level, op);

				//prepare FitTask
				FitTask* task = new FitTask("NONE", this);
				std::cout<<"m_operation_type : "<<m_operation_type<<std::endl;
				
				//set FitTask parameters from device properties
				task->set_operation_type(m_operation_type);
				task->set_pixel_size_x(pixelSizeX);
				task->set_pixel_size_y(pixelSizeY);
				task->set_optical_magnification(opticalMagnification);
				task->set_fit_nb_iterations_max(fitNbIterationsMax);
				task->set_fit_tolerance(fitTolerance);
				task->set_auto_roi_enabled(autoROIEnabled);
				task->set_auto_roi_factor_x(autoROIMagnificationFactorX);
				task->set_auto_roi_factor_y(autoROIMagnificationFactorY);
				task->set_proj_enabled(xProjEnabled, true);
				task->set_proj_enabled(yProjEnabled, false);				
				
				m_fit_task = task;
                (reinterpret_cast<SoftUserLinkTask*> (op.m_opt))->setLinkTask(task);
                return;
            }

            //NOP : if(m_operation_type == "NONE")
        }
        catch (Exception& e)
        {
            ERROR_STREAM << e.getErrMsg() << endl;
            //- throw exception
            Tango::Except::throw_exception("TANGO_DEVICE_ERROR",
                                           e.getErrMsg().c_str(),
                                           "FitGaussian::add_external_operation");
        }
        catch (yat::Exception& ex)
        {
            //throw_devfailed( ex );
            ex.dump();
            std::stringstream errMsg("");
            for (unsigned i = 0; i < ex.errors.size(); i++)
            {
                errMsg << ex.errors[i].desc << endl;
            }

            //- throw exception
            Tango::Except::throw_exception("TANGO_DEVICE_ERROR",
                                           errMsg.str().c_str(),
                                           "FitGaussian::add_external_operation");
        }
    }
}


//+------------------------------------------------------------------
/**
 *	method:	FitGaussian::dev_state
 *
 *	description:	method to execute "State"
 *	This command gets the device state (stored in its <i>device_state</i> data member) and returns it to the caller.
 *
 * @return	State Code
 *
 */
//+------------------------------------------------------------------
Tango::DevState FitGaussian::dev_state()
{
	Tango::DevState	argout = DeviceImpl::dev_state();
	DEBUG_STREAM << "FitGaussian::dev_state(): entering... !" << endl;

	//	Add your own code to control device here
    yat::AutoMutex<> _lock(ControlFactory::instance().get_global_mutex());
    stringstream DeviceStatus;
    DeviceStatus << "";
    Tango::DevState DeviceState = Tango::STANDBY;
    if (!m_is_device_initialized)
    {
        INFO_STREAM << "m_status_message = " << m_status_message.str() << endl;
        DeviceState = Tango::FAULT;
        DeviceStatus << m_status_message.str();
    }
    else
    {
        // state & status are retrieved from Factory, Factory is updated by Generic device
        DeviceState = ControlFactory::instance().get_state();
        DeviceStatus << ControlFactory::instance().get_status();
    }

    set_state(DeviceState);
    set_status(DeviceStatus.str());

    argout = DeviceState;
    return argout;
}


//-----------------------------------------------------------------------------
// method : 		FitGaussian::get_data_ptr
// description : 	Get a void* pointer to the data of a cv::Mat regardless of
//					its depth.
//-----------------------------------------------------------------------------
void* FitGaussian::get_data_ptr(const cv::Mat& img)
{
    switch(img.depth())
    {
        case CV_8U:  return const_cast<uint8_t*>(img.ptr<uint8_t>());
        case CV_8S:  return const_cast<int8_t*>(img.ptr<int8_t>());
        case CV_16U: return const_cast<uint16_t*>(img.ptr<uint16_t>());
        case CV_16S: return const_cast<int16_t*>(img.ptr<int16_t>());
        case CV_32S: return const_cast<int32_t*>(img.ptr<int32_t>());
        case CV_32F: return const_cast<float*>(img.ptr<float>());
        case CV_64F: return const_cast<double*>(img.ptr<double>());
        default: throw std::runtime_error("Unsupported image type");
    }
}






}	//	namespace
