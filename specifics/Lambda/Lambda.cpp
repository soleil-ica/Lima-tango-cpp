/*----- PROTECTED REGION ID(Lambda.cpp) ENABLED START -----*/
static const char *RcsId = "$Id:  $";
//=============================================================================
//
// file :        Lambda.cpp
//
// description : C++ source for the Lambda class and its commands.
//               The class is derived from Device. It represents the
//               CORBA servant object which will be accessed from the
//               network. All commands which can be executed on the
//               Lambda are implemented in this file.
//
// project :     Sls dectector TANGO specific device.
//
// This file is part of Tango device class.
// 
// Tango is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// Tango is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with Tango.  If not, see <http://www.gnu.org/licenses/>.
// 
// $Author:  $
//
// $Revision:  $
// $Date:  $
//
// $HeadURL:  $
//
//=============================================================================
//                This file is generated by POGO
//        (Program Obviously used to Generate tango Object)
//=============================================================================


#include <Lambda.h>
#include <LambdaClass.h>
#include <PogoHelper.h>

namespace Lambda_ns
{
	//-------------------------------------------------------------------------
	// MAX SIZES FOR STRING ATTRIBUTES
	//-------------------------------------------------------------------------
	static const size_t CONFIG_FILES_PATH_SIZE_MAX = 255; // size max
	static const size_t OPERATING_MODE_SIZE_MAX    = 255; // size max
}

/*----- PROTECTED REGION END -----*/	//	Lambda.cpp

/**
 *  Lambda class description:
 *    Device for Lambda detectors from XSpectrum.
 */

//================================================================
//  The following table gives the correspondence
//  between command and method names.
//
//  Command name  |  Method name
//================================================================
//  State         |  Inherited (no method)
//  Status        |  Inherited (no method)
//================================================================

//================================================================
//  Attributes managed are:
//================================================================
//  configFilesPath       |  Tango::DevString	Scalar
//  readoutTime           |  Tango::DevFloat	Scalar
//  distortionCorrection  |  Tango::DevBoolean	Scalar
//  energyThreshold1      |  Tango::DevFloat	Scalar
//  operatingMode         |  Tango::DevString	Scalar
//  burstMode             |  Tango::DevBoolean	Scalar
//================================================================

namespace Lambda_ns
{
/*----- PROTECTED REGION ID(Lambda::namespace_starting) ENABLED START -----*/

//	static initializations

/*----- PROTECTED REGION END -----*/	//	Lambda::namespace_starting

//--------------------------------------------------------
/**
 *	Method      : Lambda::Lambda()
 *	Description : Constructors for a Tango device
 *                implementing the classLambda
 */
//--------------------------------------------------------
Lambda::Lambda(Tango::DeviceClass *cl, string &s)
 : TANGO_BASE_CLASS(cl, s.c_str()),m_dim(this)
{
	/*----- PROTECTED REGION ID(Lambda::constructor_1) ENABLED START -----*/
	init_device();
	/*----- PROTECTED REGION END -----*/	//	Lambda::constructor_1
}
//--------------------------------------------------------
Lambda::Lambda(Tango::DeviceClass *cl, const char *s)
 : TANGO_BASE_CLASS(cl, s),m_dim(this)
{
	/*----- PROTECTED REGION ID(Lambda::constructor_2) ENABLED START -----*/
	init_device();
	/*----- PROTECTED REGION END -----*/	//	Lambda::constructor_2
}
//--------------------------------------------------------
Lambda::Lambda(Tango::DeviceClass *cl, const char *s, const char *d)
 : TANGO_BASE_CLASS(cl, s, d),m_dim(this)
{
	/*----- PROTECTED REGION ID(Lambda::constructor_3) ENABLED START -----*/
	init_device();
	/*----- PROTECTED REGION END -----*/	//	Lambda::constructor_3
}

//--------------------------------------------------------
/**
 *	Method      : Lambda::delete_device()
 *	Description : will be called at device destruction or at init command
 */
//--------------------------------------------------------
void Lambda::delete_device()
{
	DEBUG_STREAM << "Lambda::delete_device() " << device_name << endl;
	/*----- PROTECTED REGION ID(Lambda::delete_device) ENABLED START -----*/
	
    try
    {
	    // Release static attributes
        release_static_attributes();

        INFO_STREAM << "Remove the inner-appender." << endl;
        yat4tango::InnerAppender::release(this);

        m_is_device_initialized = false;
    }
    catch (Tango::DevFailed& df)
    {
        ERROR_STREAM << df << endl;
        m_status_message.str("");
        m_status_message << "Termination Failed.\n" << endl;
        m_status_message << "reason\t: " << df.errors[0].reason << endl;
        m_status_message << "Origin\t: " << df.errors[0].origin << endl;
        m_status_message << "Desc\t: "   << df.errors[0].desc   << endl;
    }
    catch (...)
    {
        ERROR_STREAM     << "Termination Failed with an unknown exception!" << endl;
        m_status_message.str("");
        m_status_message << "Termination Failed with an unknown exception!" << endl;
    }

	/*----- PROTECTED REGION END -----*/	//	Lambda::delete_device
}

//--------------------------------------------------------
/**
 *	Method      : Lambda::init_device()
 *	Description : will be called at device initialization.
 */
//--------------------------------------------------------
void Lambda::init_device()
{
	DEBUG_STREAM << "Lambda::init_device() create device " << device_name << endl;
	/*----- PROTECTED REGION ID(Lambda::init_device_before) ENABLED START -----*/

	//	Initialization before get_device_property() call
	
	/*----- PROTECTED REGION END -----*/	//	Lambda::init_device_before
	

	//	Get the device properties from database
	get_device_property();
	

	/*----- PROTECTED REGION ID(Lambda::init_device) ENABLED START -----*/
    m_is_device_initialized = false;
    set_state(Tango::INIT);
    m_status_message.str("");

    INFO_STREAM << "Create the inner-appender in order to manage logs." << endl;  
    yat4tango::InnerAppender::initialize(this, 512);

	try
	{
		//- get the main object used to pilot the lima framework		
		m_ct = ControlFactory::instance().get_control("Lambda");
		
		//- get interface to specific camera
		m_hw = dynamic_cast<lima::Lambda::Interface*>(m_ct->hwInterface());
		
		//- get camera to specific detector
		m_camera = &(m_hw->getCamera());

	    // Create static attributes
        create_static_attributes();

        // Update the hardware with the properties data
        write_at_init();

        //	Initialize device
	    m_is_device_initialized = true;
	    set_state(Tango::STANDBY);
	    dev_state();	
	}
	catch(Exception& e)
	{
		INFO_STREAM      << "Initialization Failed : " << e.getErrMsg() << endl;
		m_status_message << "Initialization Failed : " << e.getErrMsg( ) << endl;
		m_is_device_initialized = false;
		set_state(Tango::FAULT);
		return;
	}
	catch(...)
	{
		INFO_STREAM      << "Initialization Failed : UNKNOWN" << endl;
		m_status_message << "Initialization Failed : UNKNOWN" << endl;
		set_state(Tango::FAULT);
		m_is_device_initialized = false;
		return;
	}

	/*----- PROTECTED REGION END -----*/	//	Lambda::init_device
}

//--------------------------------------------------------
/**
 *	Method      : Lambda::get_device_property()
 *	Description : Read database to initialize property data members.
 */
//--------------------------------------------------------
void Lambda::get_device_property()
{
	/*----- PROTECTED REGION ID(Lambda::get_device_property_before) ENABLED START -----*/
	
	//	Initialize property data members
	
	/*----- PROTECTED REGION END -----*/	//	Lambda::get_device_property_before


	//	Read device properties from database.
	Tango::DbData	dev_prop;
	dev_prop.push_back(Tango::DbDatum("ConfigFilesPath"));
	dev_prop.push_back(Tango::DbDatum("DistortionCorrection"));
	dev_prop.push_back(Tango::DbDatum("MemorizedEnergyThreshold1"));

	//	is there at least one property to be read ?
	if (dev_prop.size()>0)
	{
		//	Call database and extract values
		if (Tango::Util::instance()->_UseDb==true)
			get_db_device()->get_property(dev_prop);
	
		//	get instance on LambdaClass to get class property
		Tango::DbDatum	def_prop, cl_prop;
		LambdaClass	*ds_class =
			(static_cast<LambdaClass *>(get_device_class()));
		int	i = -1;

		//	Try to initialize ConfigFilesPath from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  configFilesPath;
		else {
			//	Try to initialize ConfigFilesPath from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  configFilesPath;
		}
		//	And try to extract ConfigFilesPath value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  configFilesPath;

		//	Try to initialize DistortionCorrection from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  distortionCorrection;
		else {
			//	Try to initialize DistortionCorrection from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  distortionCorrection;
		}
		//	And try to extract DistortionCorrection value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  distortionCorrection;

		//	Try to initialize MemorizedEnergyThreshold1 from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  memorizedEnergyThreshold1;
		else {
			//	Try to initialize MemorizedEnergyThreshold1 from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  memorizedEnergyThreshold1;
		}
		//	And try to extract MemorizedEnergyThreshold1 value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  memorizedEnergyThreshold1;

	}

	/*----- PROTECTED REGION ID(Lambda::get_device_property_after) ENABLED START -----*/
	
	//	Check device property data members init
	yat4tango::PropertyHelper::create_property_if_empty(this, dev_prop, "/opt/xsp/config", "ConfigFilesPath"              );
	yat4tango::PropertyHelper::create_property_if_empty(this, dev_prop, "True"  , "DistortionCorrection");
	yat4tango::PropertyHelper::create_property_if_empty(this, dev_prop, "7000.0", "MemorizedEnergyThreshold1"    );
	/*----- PROTECTED REGION END -----*/	//	Lambda::get_device_property_after
}

//--------------------------------------------------------
/**
 *	Method      : Lambda::always_executed_hook()
 *	Description : method always executed before any command is executed
 */
//--------------------------------------------------------
void Lambda::always_executed_hook()
{
	DEBUG_STREAM << "Lambda::always_executed_hook()  " << device_name << endl;
	/*----- PROTECTED REGION ID(Lambda::always_executed_hook) ENABLED START -----*/
	
	//	code always executed before all requests
    try
    {
        m_status_message.str("");

        //update state
        dev_state();
    }
    catch (Exception& e)
    {
        ERROR_STREAM << e.getErrMsg() << endl;
        m_status_message << "always_executed_hook : " << e.getErrMsg() << endl;
        //- throw exception
        set_state(Tango::FAULT);
        m_is_device_initialized = false;
        return;
    }
    catch (...)
    {
        ERROR_STREAM << "always_executed_hook : UNKNOWN" << endl;
        m_status_message << "always_executed_hook : UNKNOWN" << endl;
        //- throw exception
        set_state(Tango::FAULT);
        m_is_device_initialized = false;
        return;
    }
	
	/*----- PROTECTED REGION END -----*/	//	Lambda::always_executed_hook
}

//--------------------------------------------------------
/**
 *	Method      : Lambda::read_attr_hardware()
 *	Description : Hardware acquisition for attributes
 */
//--------------------------------------------------------
void Lambda::read_attr_hardware(TANGO_UNUSED(vector<long> &attr_list))
{
	DEBUG_STREAM << "Lambda::read_attr_hardware(vector<long> &attr_list) entering... " << endl;
	/*----- PROTECTED REGION ID(Lambda::read_attr_hardware) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	Lambda::read_attr_hardware
}
//--------------------------------------------------------
/**
 *	Method      : Lambda::write_attr_hardware()
 *	Description : Hardware writing for attributes
 */
//--------------------------------------------------------
void Lambda::write_attr_hardware(TANGO_UNUSED(vector<long> &attr_list))
{
	DEBUG_STREAM << "Lambda::write_attr_hardware(vector<long> &attr_list) entering... " << endl;
	/*----- PROTECTED REGION ID(Lambda::write_attr_hardware) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	Lambda::write_attr_hardware
}

//--------------------------------------------------------
/**
 *	Read attribute configFilesPath related method
 *	Description: Path of configuration file.
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void Lambda::read_configFilesPath(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Lambda::read_configFilesPath(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(Lambda::read_configFilesPath) ENABLED START -----*/
    try
    {
        std::string temp = m_camera->getConfigFilePath();
        strcpy(*attr_configFilesPath_read, temp.c_str());
        attr.set_quality(Tango::ATTR_VALID);
    	attr.set_value(attr_configFilesPath_read);
    }
    catch (Tango::DevFailed& df)
    {
        manage_devfailed_exception(df, "read_configFilesPath");
    }

	/*----- PROTECTED REGION END -----*/	//	Lambda::read_configFilesPath
}
//--------------------------------------------------------
/**
 *	Read attribute readoutTime related method
 *	Description: get readout time during image acquisition.<br>
 *               Depends of the operating mode.<br>
 *
 *	Data type:	Tango::DevFloat
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void Lambda::read_readoutTime(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Lambda::read_readoutTime(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(Lambda::read_readoutTime) ENABLED START -----*/
    try
    {
        *attr_readoutTime_read = m_camera->getReadoutTimeMs();
        attr.set_quality(Tango::ATTR_VALID);
    	attr.set_value(attr_readoutTime_read);
    }
    catch (Tango::DevFailed& df)
    {
        manage_devfailed_exception(df, "read_readoutTime");
    }

	/*----- PROTECTED REGION END -----*/	//	Lambda::read_readoutTime
}
//--------------------------------------------------------
/**
 *	Read attribute distortionCorrection related method
 *	Description: get distortion correction.<br>
 *               When distortion correction is enabled :<br>
 *               - Large pixels are divided according to predefined denominator. <br>
 *               - The values of the pixels are rounded during division. <br>
 *               - If pixel value is saturated, the division is not applied.<br>
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void Lambda::read_distortionCorrection(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Lambda::read_distortionCorrection(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(Lambda::read_distortionCorrection) ENABLED START -----*/
    try
    {
        *attr_distortionCorrection_read = m_camera->getDistortionCorrection();
        attr.set_quality(Tango::ATTR_VALID);
    	attr.set_value(attr_distortionCorrection_read);
    }
    catch (Tango::DevFailed& df)
    {
        manage_devfailed_exception(df, "read_distortionCorrection");
    }

	/*----- PROTECTED REGION END -----*/	//	Lambda::read_distortionCorrection
}
//--------------------------------------------------------
/**
 *	Read attribute energyThreshold1 related method
 *	Description: set/get first energy threshold in eV.<br>
 *               The photon is counted If the energy is above this threshold.<br>
 *
 *	Data type:	Tango::DevFloat
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void Lambda::read_energyThreshold1(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Lambda::read_energyThreshold1(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(Lambda::read_energyThreshold1) ENABLED START -----*/
    try
    {
        *attr_energyThreshold1_read = m_camera->getThresholdEnergy(0);
        attr.set_quality(Tango::ATTR_VALID);
    	attr.set_value(attr_energyThreshold1_read);
    }
    catch (Tango::DevFailed& df)
    {
        manage_devfailed_exception(df, "read_energyThreshold1");
    }
	
	/*----- PROTECTED REGION END -----*/	//	Lambda::read_energyThreshold1
}
//--------------------------------------------------------
/**
 *	Write attribute energyThreshold1 related method
 *	Description: set/get first energy threshold in eV.<br>
 *               The photon is counted If the energy is above this threshold.<br>
 *
 *	Data type:	Tango::DevFloat
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void Lambda::write_energyThreshold1(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "Lambda::write_energyThreshold1(Tango::WAttribute &attr) entering... " << endl;
	//	Retrieve write value
	Tango::DevFloat	w_val;
	attr.get_write_value(w_val);
	/*----- PROTECTED REGION ID(Lambda::write_energyThreshold1) ENABLED START -----*/
    try
    {
        float data = static_cast<float>(w_val);
        m_camera->setThresholdEnergy(0, data);
        yat4tango::PropertyHelper::set_property(this, "MemorizedEnergyThreshold1", w_val);
    }
    catch (Tango::DevFailed& df)
    {
        manage_devfailed_exception(df, "write_energyThreshold1");
    }
	
	/*----- PROTECTED REGION END -----*/	//	Lambda::write_energyThreshold1
}
//--------------------------------------------------------
/**
 *	Read attribute operatingMode related method
 *	Description: get operating mode of the detector:<br>
 *               24bit mode : TwentyFourBit<br>
 *               12bit mode :  ContinuousReadWrite<br>
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void Lambda::read_operatingMode(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Lambda::read_operatingMode(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(Lambda::read_operatingMode) ENABLED START -----*/
	//	Set the attribute value
    try
    {
        std::string temp = m_camera->getOperationMode();

        strcpy(*attr_operatingMode_read, temp.c_str());
        attr.set_quality(Tango::ATTR_VALID);
    	attr.set_value(attr_operatingMode_read);
    }
    catch (Tango::DevFailed& df)
    {
        manage_devfailed_exception(df, "read_operatingMode");
    }
	
	/*----- PROTECTED REGION END -----*/	//	Lambda::read_operatingMode
}
//--------------------------------------------------------
/**
 *	Read attribute burstMode related method
 *	Description: get the value of burst mode.<br>
 *               true: 10GE link.<br>
 *               false: 1GE link<br>
 *
 *	Data type:	Tango::DevBoolean
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void Lambda::read_burstMode(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Lambda::read_burstMode(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(Lambda::read_burstMode) ENABLED START -----*/
    try
    {
        *attr_burstMode_read = m_camera->getBurstMode();
        attr.set_quality(Tango::ATTR_VALID);
    	attr.set_value(attr_burstMode_read);
    }
    catch (Tango::DevFailed& df)
    {
        manage_devfailed_exception(df, "read_burstMode");
    }
	
	/*----- PROTECTED REGION END -----*/	//	Lambda::read_burstMode
}

//--------------------------------------------------------
/**
 *	Method      : Lambda::add_dynamic_attributes()
 *	Description : Create the dynamic attributes if any
 *                for specified device.
 */
//--------------------------------------------------------
void Lambda::add_dynamic_attributes()
{
	/*----- PROTECTED REGION ID(Lambda::add_dynamic_attributes) ENABLED START -----*/
	
	//	Add your own code to create and add dynamic attributes if any
	
	/*----- PROTECTED REGION END -----*/	//	Lambda::add_dynamic_attributes
}


/*----- PROTECTED REGION ID(Lambda::namespace_ending) ENABLED START -----*/

//	Additional Methods
//+------------------------------------------------------------------
/**
 *	method:	Lambda::dev_state
 *
 *	description:	method to execute "State"
 *	This command gets the device state (stored in its <i>device_state</i> data member) and returns it to the caller.
 *
 * @return	State Code
 *
 */
//+------------------------------------------------------------------
Tango::DevState Lambda::dev_state()
{
    Tango::DevState	argout = DeviceImpl::dev_state();
    DEBUG_STREAM << "Lambda::dev_state(): entering... !" << endl;

    // Add your own code to control device here
    stringstream DeviceStatus;
    DeviceStatus << "";
    Tango::DevState DeviceState = Tango::STANDBY;

    if(!m_is_device_initialized )
    {
        DeviceState  = Tango::FAULT;
        DeviceStatus << m_status_message.str();
    }
    else
    {
        // state & status are retrieved from Factory, Factory is updated by Generic device
        DeviceState = ControlFactory::instance().get_state();
        DeviceStatus << ControlFactory::instance().get_status();
    }

    set_state (DeviceState);
    set_status(DeviceStatus.str());

    return DeviceState;
}

//+------------------------------------------------------------------
/**
 *	method:	Lambda::manage_devfailed_exception
 *
 *	description: method which manages DevFailed exceptions
 */
//+------------------------------------------------------------------
void Lambda::manage_devfailed_exception(Tango::DevFailed & in_exception, const std::string & in_caller_method_name)
{
    ERROR_STREAM << in_exception << endl;
	
    // rethrow exception
    Tango::Except::re_throw_exception(in_exception,
                                      "TANGO_DEVICE_ERROR",
                                      string(in_exception.errors[0].desc).c_str(),
                                      in_caller_method_name.c_str());
}

//+------------------------------------------------------------------
/**
 *	method:	Lambda::manage_lima_exception
 *
 *	description: method which manages lima exceptions
 */
//+------------------------------------------------------------------
void Lambda::manage_lima_exception(lima::Exception & in_exception, const std::string & in_caller_method_name)
{
    ERROR_STREAM << in_exception.getErrMsg() << endl;

    // throw exception
    Tango::Except::throw_exception("TANGO_DEVICE_ERROR",
                                   in_exception.getErrMsg().c_str(),
                                   in_caller_method_name.c_str());
}

/*************************************************************************************************************
 * \brief Use to update a string static attribute and the hardware with a property value
 * \param[in]  in_attribute_name     Name of the attribute linked to the property value
 * \param[out] out_attr_read         Tango attribute member to filled with the data value
 * \param[in]  in_memorized_property Property variable
 * \param[in]  in_write_method       Pointer on a controller method to call to set the data
*************************************************************************************************************/
void Lambda::write_property_in_string_static_attribute(const std::string & in_attribute_name,
                                                       Tango::DevString * out_attr_read,
                                                       const std::string & in_memorized_property,
                                                       void (Lambda_ns::Lambda::*in_write_method)(Tango::WAttribute &))
{
	INFO_STREAM << "Write tango hardware at Init - " << in_attribute_name << "." << endl;

    strcpy(*out_attr_read, in_memorized_property.c_str());
	Tango::WAttribute & attribute = dev_attr->get_w_attr_by_name(in_attribute_name.c_str());
	attribute.set_write_value(*out_attr_read);
    (this->*in_write_method)(attribute);
}

/*****************************************************************************
 * \brief Create the static attributes
 *****************************************************************************/
void Lambda::create_static_attributes(void)
{
    INFO_STREAM << "- Create the static attributes" << endl;

    CREATE_SCALAR_ATTRIBUTE(attr_readoutTime_read         , (Tango::DevFloat  )0.0f    );
    CREATE_SCALAR_ATTRIBUTE(attr_distortionCorrection_read, (Tango::DevBoolean)true    );
    CREATE_SCALAR_ATTRIBUTE(attr_burstMode_read           , (Tango::DevBoolean)true    );
    CREATE_SCALAR_ATTRIBUTE(attr_energyThreshold1_read    , (Tango::DevFloat  )7000.0f );

    CREATE_DEVSTRING_ATTRIBUTE(attr_configFilesPath_read, Lambda_ns::CONFIG_FILES_PATH_SIZE_MAX);
    CREATE_DEVSTRING_ATTRIBUTE(attr_operatingMode_read  , Lambda_ns::OPERATING_MODE_SIZE_MAX   );
}

/*****************************************************************************
 * \brief Release the static attributes
 *****************************************************************************/
void Lambda::release_static_attributes(void)
{
    INFO_STREAM << "- Remove the static attributes" << endl;

    DELETE_SCALAR_ATTRIBUTE(attr_readoutTime_read         );
    DELETE_SCALAR_ATTRIBUTE(attr_distortionCorrection_read);
    DELETE_SCALAR_ATTRIBUTE(attr_burstMode_read           );
    DELETE_SCALAR_ATTRIBUTE(attr_energyThreshold1_read    );

    DELETE_DEVSTRING_ATTRIBUTE(attr_configFilesPath_read);
    DELETE_DEVSTRING_ATTRIBUTE(attr_operatingMode_read  );
}

/*****************************************************************************
 * \brief Update the hardware with the properties data
 *****************************************************************************/
void Lambda::write_at_init(void)
{
    INFO_STREAM << "- Update the hardware with the properties" << endl;

    write_property_in_static_attribute("energyThreshold1"    , attr_energyThreshold1_read    , memorizedEnergyThreshold1     , &Lambda::write_energyThreshold1   );

    // no need to compress the image by the camera during acquisition
    force_precompressEnabled(false);
}

//--------------------------------------------------------
/**
 *	Force the precompressEnabled option
 *	Description: set precompression.
 */
//--------------------------------------------------------
void Lambda::force_precompressEnabled(bool value)
{
	DEBUG_STREAM << "Lambda::force_precompressEnabled entering... " << endl;

    try
    {
        bool compression_enabled;
        int  comp_level;

        m_camera->getCompressionEnabled(compression_enabled, comp_level);
        m_camera->setCompressionEnabled(value, comp_level); // keep the previous compression level
    }
    catch (Tango::DevFailed& df)
    {
        manage_devfailed_exception(df, "force_precompressEnabled");
    }
}

/*----- PROTECTED REGION END -----*/	//	Lambda::namespace_ending
} //	namespace
